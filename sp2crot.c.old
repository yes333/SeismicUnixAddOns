/* Copyright (c) READ Well Services, 2010.*/
/* All rights reserved.                       */

/* SPCOMPROT v. 1.0 written by Sanyu Ye */


#include <cwp.h>
#include <su.h>
#include <header.h>
#include <segy.h>
#include <segyhdr.h>

/*********************** self documentation ******************************/
char *sdoc[] = {
"                                                                               ",
" SP2CROT  -  Compute and apply 2 component rotation along a given axis         ",
"             for either 4C OBC or 3C VSP data            ",
"                                                                               ",
"   sp2crot <stdin >stdout [options]                                          ",
"                                                                               ",
" Optional Parameters:                                                          ",
"                                                                               ",
"   nc=3          number of input components in order [H,] C3, C2 and C1, trace by trace",
"                 for VSP in order Z, H1, H2                                    ",
"                 =4 for OBC Hydrophone(H), Vertical(Z), Inline(X) and Crossline(Y)",
"                                                                               ",
"   axis=-3       rotation axis, count backward from last component             ",
"                 =-3 rotate along C3 (Z) from C1 (Y) towards C2 (X)            ",
"                 =-2 rotate along C2 (X) from C3 (Z) towards C1 (Y)            ",
"                 =-1 rotate along C1 (Y) from C2 (X) towards C3 (Z)            ",
"                                                                               ",
"   mode=0        =0 apply rotation, angle positive from C1 to C2 while along C3, and so further",
"                 =1 compute orientation/rotation angle                         ",
"                 =2 compute orientation and apply rotation                     ",
"                                                                               ",
"   key=cdpt      receiver gather sort key, used to compute angle               ",
"   nxmax=512     max. number of traces for a component expected in a gather    ",
"                                                                               ",
"   a=wevel       keyword rotation angle is saved or fetched                    ",
"   scale=0.01    scaling factor to convert angle in degrees (-180 ~ 180)       ",
"                                                                               ",
"   gdepth=gelev  keyword holding geophone depth, scaled by scalco as usual     ",
"                                                                               ",
" Parameters used to control applying rotation:                                 ",
"                                                                               ",
"   vsp=2         =0 just apply plain rotation                                  ",
"                 =1 rotate 1st component with max. energy                      ",
"                 =2 rotate 2nd component with max. energy, e.g. on H1          ",
"                                                                               ",
" Parameters used to determine orientation angle of first of two components: 	",
"                                                                               ",
"   t0=1.0  [s]   time line peaks of first arrivals are aligned on              ",
"                 i.e. FTB for VSP, first positive peak for OBC data            ",
"   t1=0.98 [s]   start of time window to determine rotation angles             ",
"                 should be set possibly close to onset of first arrivals       ",
"   t2=1.04 [s]   end of time window to determine rotation angle                ",
"                                                                               ",
"   base=0        =0  use azimuth source-receiver as base line                  ",
"                 =1  use incident angle at receiver as base line               ",
"   da=0.5 [deg]  increment of rotation angle                                   ",
"   as=6.0 [deg]  angle (size) of sector to compute median value of orientation ",
"                                                                               ",
"   verbose=0     >0 output info                                                ",
"                                                                               ",
" Note:                                                                         ",
"   C1, C2, C3 or H2, H1, Z must build a right hand Cartesian coordinate system. ",
"   For OBC input data must be sorted by hydrophone (H), if present, vertical (Z),",
"   inline (X) and crossline (Y) while for VSP in Z, H1, H2.                    ",
"   Z (C3) axis is positive downwards, so the inline component that normally    ",
"   coincides with surface X axis is treated by this program as Y (C2) internally",
"   while surface Y as  X (C1)                                                  ",
"   If only 2 components input, first trace is considered as C2 (Y)             ",
"   In case of multiple sources in a gather, distribution of determined orientation",
"   angles is computed. The sector with highest concentration and its two neighbouring",
"   sectors are used to determine the median value.                             ",
"   The program compute rms amplitude of the given window while rotate from first",
"   (X) to second axis (Y). The orientation of X is determined separately by max",
"   ernergy on X, Y and ratio X/Y. Normally all three results should be similar,",
"   particlarly their median values. A difference of around 180 degrees of the median",
"   value of Y to other two values indicate possible polarity reversal of either",
"   X or Y component. In other words when rotation is applied X always shows correct",
"   polarity while Y on that receiver station shows reversed polarity if compared",
"   to other receivers.                                                         ",
"   The orientation angles determined by individual shot are stored in fx,fy,fz ",
"   while their median values in dx,dy,dz. In addition the median value of X is ",
"   stored in keyword specified by a=key.                                       ",
"                                                                               ",
" Examples:                                                                     ",
" 1. align FTB at 1 sec and compute orientation angle of H2 for VSP          ",
" suchw key1=tstat key2=gwdep b=0.1 a=-1000 < input.su |\\                      ",
" sustatic hdrs=1 |\\                      ",
" sp2crot mode=1 nc=3 axis=-3 key=gdel > output.su                          ",
"                                                                               ",
"                                                                               ",
"                                                                               ",
NULL};

/* Credits:
 *	Sanyu Ye: READ Well Services, May. 2010
 */
/**************** end self doc *******************************************/

// forward declaration
float calcRot(int ntr, int itftb, int itmin, int itmax, float da,
               float* baseangle, float** x, float** y, float** angles);
float quick_select(float *arr, int n);
void Rotate(int ntr, int nt, int vsp, float* baseangle, float angle, float** x, float** y);
void Rotate2C(int itmin, int itmax, int skip, float angle, float* x, float* y, float* x1, float* y1);
float calcRMS(int nt, float* data);
float getMedianAngle(int ntr, float* ax, float alimit, float* stddiv, int* n);
float stddev(float* a, int n, float avg);

int verbose;		/* =0 no info, >0 output info  */

int main(int argc, char **argv) {
    cwp_String key, key_a, key_g;	/* header key word from segy.h		*/
    cwp_String type, type_a, type_g;    /* type of key				*/
    Value val, valnew, vala;                  /* value of key			*/
    int index, index_a, index_g;         /* index of key				*/
    int nt, itftb, itmin, itmax;       /* nums amps as int			*/
    int axis, xaxis, yaxis, base;
    int nc, nxmax;                     /* number of components			*/
    int nsegy;                  /* length bytes read for segy trace	*/
    int mode, vsp;
    float a, asector, da;                    /* rotation angle computed or applied   */
    float t0, t1, t2, dt, scale;                /* input trace px py header values */
    float axm, aym, arm, stddvax, stddvay, stddvar;
    int naxm, naym, narm;
    int i, itr, ntr, nsrc, ngather, total;
    segy tr, outtr;

    
    /* Initialize */
    initargs(argc, argv);
    requestdoc(0);

    if (!getparint("verbose", &verbose)) verbose=0;

    /* get keys */
    if (!getparstring("a", &key_a))	 key_a="wevel";
    type_a = hdtype(key_a);
    index_a = getindex(key_a);
    if (!getparstring("gdepth", &key_g)) key_g="gelev";
    type_g = hdtype(key_g);
    index_g = getindex(key_g);
    if (!getparstring("key", &key))	 key="cdpt";
    type = hdtype(key);
    index = getindex(key);

    if (!getparfloat("scale", &scale))  scale = 0.01;
    if (!getparfloat("as", &asector))   asector = 6.0;
    if (!getparfloat("da", &da))        da = 0.5;
    if (!getparint("nxmax", &nxmax))    nxmax = 512;

    if (!getparint("vsp", &vsp))     vsp = 2;
    if (!getparint("nc", &nc))        nc = 3;
    if (!getparint("mode", &mode))  mode = 0;
    if (!getparint("axis", &axis))  axis = -3;
    else {
        if (axis >=0 || axis < -3 || axis < -nc)
            err("invalid axis (=%d), should be between -1 and -3, count backwards", axis);
    }
    if (!getparint("base", &base))  base = 0;
    else {
        if ( !(base == 0 || base == 1) )
            err("invalid base line (=%d), should be azimuth (=0) or incident angle (=1)", base);
    }
    // find out component index corresponding to x and y axis
    if (nc == 2) {
        xaxis = 1;
        yaxis = 0;
    } else {
        xaxis = nc + axis - 1;
        yaxis = nc + axis - 2;
        if (xaxis < nc - 3) xaxis += nc;
        if (yaxis < nc - 3) yaxis += nc;
    }

    /* get first trace */
    if ( (nsegy=gettr(&tr)) < HDRBYTES) err("can't get first trace");
    gethval(&tr, index, &val);

    dt = ((double) tr.dt) / 1000000.0;
    nt = tr.ns;

    if (!getparfloat("t0", &t0)) t0 = 1.0;
    if (!getparfloat("t1", &t1)) t1 = 0.98;
    if (!getparfloat("t2", &t2)) t2 = 1.04;
    itftb = NINT(t0 / dt);
    itmin = NINT(t1 / dt);
    itmax = NINT(t2 / dt);
    /* Check time gating values */
    if (itmin < 0)
        err("itmin=%d should be positive", itmin);
    if (itftb < itmin)
        err("t0 %5.3f should be larger than t1 %5.3f", t0, t1);
    if (itmin > itmax)
        err("itmin=%d, itmax=%d conflict", itmin, itmax);
    if (tr.ns <= itmax)
        err("tr.ns=%d, itmax=%d window cannot extend over the trace length", tr.ns, itmax);
    
    segyhdr** hdrs = (segyhdr **) ealloc2(nxmax, nc, HDRBYTES);
    float***  indata = ealloc3float(nt, nxmax, nc);
    float*** outdata = ealloc3float(nt, nxmax, nc);
    float** baseangle = ealloc2float(nxmax, 2);
    float** angles = ealloc2float(nxmax, 3);
    
    //decomposing wavefield
    memset(*hdrs, 0, nc * nxmax * HDRBYTES);
    memset( **indata, 0, nc * nxmax * nt * FSIZE);
    memset(**outdata, 0, nc * nxmax * nt * FSIZE);
    memset(*baseangle, 0, 2 * nxmax * FSIZE);
    memset(*angles, 0, 3 * nxmax * FSIZE);

    /* Read headers and data while getting a count */
    int eof = 0;
    ngather = ntr = total = 0;
    do {
        if (nsegy > HDRBYTES) gethval(&tr, index, &valnew);
        else eof = 1; //END_OF_FILE
        if (nsegy > HDRBYTES && !valcmp(type, val, valnew)) { /* same key and more data*/
            if (ntr > nc*(nxmax - 1)) err("\nNumber of traces exceeding nxmax=%d\n", nxmax);
            memcpy(&hdrs[ntr%nc][ntr/nc], &tr, HDRBYTES);
            memcpy(indata[ntr%nc][ntr/nc], tr.data, FSIZE * nt);
            if (!(ntr%nc)) {
                int isrc = ntr/nc;
                float y = tr.sx - tr.gx;
                float x = tr.sy - tr.gy;
                float dist = sqrt(x*x + y*y);
                gethval(&tr, index_g, &vala);
                float z = vtoi(type_g, vala) - tr.sdepth;
                baseangle[0][isrc] = 180/PI*atan2(-y, -x);
                baseangle[1][isrc] = 180/PI*atan2(z, dist);
            }
            ++ntr;
            val = valnew;
        } else { // new gather or END_OF_FILE
            ++ngather;
            if (verbose>1) warn("  processing %d traces %d-th gather (%s=%d)", ntr, ngather, key, vtoi(type, val));
            if (ntr%nc) err(" number of traces not multiple of number of components for %d-th gather (%s=%d)",
                    ntr, ngather, key, vtoi(type, val));

            nsrc = ntr/nc;
            total += ntr;

            stddvax = stddvay = stddvar = 0.0;
            if ( mode == 0 ) { // fetch angle
                gethval((segy*) &hdrs[0], index_a, &vala);
                a = vtod(type_a, vala)*scale;
            } else { // do calculate rotation angle
                calcRot(nsrc, itftb, itmin, itmax, da, baseangle[base], indata[xaxis], indata[yaxis], angles);
                a = axm = getMedianAngle(nsrc, angles[0], asector, &stddvax, &naxm);
                aym = getMedianAngle(nsrc, angles[1], asector, &stddvay, &naym);
                arm = getMedianAngle(nsrc, angles[2], asector, &stddvar, &narm);
                stddvax = stddev(angles[0], nsrc, axm);
                stddvay = stddev(angles[1], nsrc, aym);
                stddvar = stddev(angles[2], nsrc, arm);

                vala.h = (short) NINT(axm/scale);
                //vala.i = (int) (a/scale);
                if (verbose>1) warn(" Orientation/Azimuth determined by rms X, Y and X/Y: %6.5f %6.5f %6.5f ",
                        axm, aym, arm);
                if (verbose) warn(" Orientation/Azimuth of C%d = %.5f (degrees) for %d-th gather (%s=%d)",
                        nc - xaxis, a, ngather, key, vtoi(type, val));
            }
            if (mode==0 || mode == 2) { // apply rotation
                Rotate(nsrc, nt, vsp, baseangle[base], a, indata[xaxis], indata[yaxis]);
            }

            for (itr = 0; itr < nsrc; ++itr) {
                for (i = 0; i < nc; ++i) {
                    memcpy(&outtr, &hdrs[i][itr], HDRBYTES);
                    memcpy(outtr.data, indata[i][itr], FSIZE * nt);
                    if (mode > 0) {
                        outtr.lcf  = nsrc;
                        outtr.hcf  = naxm;
                        outtr.lcs  = naym;
                        outtr.hcs  = narm;
                        outtr.year   = NINT(100.0*baseangle[0][itr]);
                        outtr.day    = NINT(100.0*baseangle[1][itr]);
                        outtr.hour   = NINT(100.0*angles[0][itr]);
                        outtr.minute = NINT(100.0*angles[1][itr]);
                        outtr.sec    = NINT(100.0*angles[2][itr]);
                        outtr.timbas = NINT(100.0*axm);
                        outtr.grnors = NINT(100.0*aym);
                        outtr.grnlof = NINT(100.0*arm);
                        if(stddvax > 0.0) outtr.trwf    = NINT(100.0*stddvax);
                        if(stddvay > 0.0) outtr.grnofr  = NINT(100.0*stddvay);
                        if(stddvar > 0.0) outtr.gaps    = NINT(100.0*stddvar);
                        puthval(&outtr, index_a, &vala);
                        outtr.fx = angles[0][itr];
                        outtr.fy = angles[1][itr];
                        outtr.fz = angles[2][itr];
                        outtr.dx = stddvax;
                        outtr.dy = stddvay;
                        outtr.dz = stddvar;
                    }
                    puttr(&outtr);
                }
            }
            
            val = valnew;
            // reset output data
            memset(**indata, 0, nc * nxmax * nt * FSIZE);
            memset(*hdrs, 0, nc * nxmax * HDRBYTES);
            memset(*baseangle, 0, 2 * nxmax * FSIZE);
            memset(*angles, 0, 3 * nxmax * FSIZE);
            ntr = 0;
            continue;
        }
        nsegy = gettr(&tr);
    } while (!eof);

    if (verbose) warn(" Totally %d traces for each of %d compomnents are processed", total/nc, nc);
    
    return(CWP_Exit());
}

float calcRot(int nsrc, int itftb, int itmin, int itmax, float da, float* baseangle, float** x, float** y, float** angles)
{
    int itr;
    float a, axftb, ayftb, arftb;
    float xaa, xab, yaa, yab, raa, rab;
    float xrms, yrms, ratio;

    float* ax = ealloc1float(nsrc);
    float* ay = ealloc1float(nsrc);
    float* ar = ealloc1float(nsrc);
    float* xrmsmax = ealloc1float(nsrc);
    float* yrmsmax = ealloc1float(nsrc);
    float* rrmsmax = ealloc1float(nsrc);
    memset(ax, 0, nsrc*FSIZE);
    memset(ay, 0, nsrc*FSIZE);
    memset(ar, 0, nsrc*FSIZE);
    memset(xrmsmax, 0, nsrc*FSIZE);
    memset(yrmsmax, 0, nsrc*FSIZE);
    memset(rrmsmax, 0, nsrc*FSIZE);

    int nt = itmax - itmin + 1;
    float* x1 = ealloc1float(nt);
    float* y1 = ealloc1float(nt);

    xaa = xab = yaa = yab = raa = rab = 0.0;
    for (itr=0; itr<nsrc; ++itr) {
        for (a = 0; a <= 180.0; a += da) {
            Rotate2C(itmin, itmax, 1, a, x[itr], y[itr], x1, y1);
            xrms = calcRMS(nt, x1);
            yrms = calcRMS(nt, y1);
            ratio = (yrms == 0.0)? 0.0 : xrms / yrms;
            if (xrms > xrmsmax[itr] ) {
                axftb = x1[itftb-itmin];
                ax[itr] = baseangle[itr] - a;
                if (axftb < 0) ax[itr] -= 180.0;
                if (ax[itr] >  180) ax[itr] -= 360.0;
                if (ax[itr] < -180) ax[itr] += 360.0;
                xrmsmax[itr] = xrms;
            }
            if (yrms > yrmsmax[itr] ) {
                ayftb = x1[itftb-itmin];
                ay[itr] = baseangle[itr] + 90.0 - a;
                if (ayftb < 0) ay[itr] -= 180.0;
                if (ay[itr] >  180) ay[itr] -= 360.0;
                if (ay[itr] < -180) ay[itr] += 360.0;
                yrmsmax[itr] = yrms;
            }
            if (ratio > rrmsmax[itr] ) {
                arftb = x1[itftb-itmin];
                ar[itr] = baseangle[itr] - a;
                if (arftb < 0) ar[itr] -= 180.0;
                if (ar[itr] >  180) ar[itr] -= 360.0;
                if (ar[itr] < -180) ar[itr] += 360.0;
                rrmsmax[itr] = ratio;
            }
        }
        angles[0][itr] = ax[itr];
        angles[1][itr] = ay[itr];
        angles[2][itr] = ar[itr];
    }

    free1float(x1);
    free1float(y1);
    free1float(ax);
    free1float(ay);
    free1float(ar);
    free1float(xrmsmax);
    free1float(yrmsmax);
    free1float(rrmsmax);

    return 0.0;
}


float getMedianAngle(int ntr, float* ax, float alimit, float* stddiv, int* n)
{
    int i, itr, na = 0, imaxsector = 0, maxcount = 0 ;
    int nsector = 360/alimit;
    int* count = ealloc1int(nsector);
    memset(count, 0, nsector*sizeof(int));
    for (itr=0; itr<ntr; ++itr) {
        if (ax[itr] == 0.0) continue;  // exclude hard zero, probably not determined value
        i = (int)((ax[itr] + 180.0)/alimit);
        if (i < 0 || i > nsector - 1) continue;
        //if (i < 0) i += nsector;
        //if (i > nsector -1) i -= nsector;
        count[i]++;
    }
    for (i = 0; i < nsector; ++i) {
        if (count[i] > maxcount) {
            imaxsector = i;
            maxcount = count[i];
        }
    }
    float amin = (imaxsector - 1) * alimit - 180.0;
    float amax = (imaxsector + 2) * alimit - 180.0;
    for (itr=0; itr<ntr; ++itr) {
        if (ax[itr] == 0.0) continue;  // exclude hard zero, probably not determined value
        if (imaxsector == nsector - 1 && ax[itr] < -180.0 + alimit) ax[itr] += 360.0;  // -180 ~ -180 + 6
        if (imaxsector == 0 && ax[itr] >  180.0 - alimit) ax[itr] -= 360.0;            // 180 - 6 ~ 180
        if ( ax[itr] < amax && ax[itr] > amin ) ax[na++] = ax[itr];
    }
    if (na == 0) {
        warn("no non-hardzero present, return 0");
        return 0.0;
    }

    float axm = quick_select(ax, na);
    if (stddiv) *stddiv = stddev(ax, na, axm);
    if (n) *n = na;

    if (axm >  180.0) axm -= 360.0;
    if (axm < -180.0) axm += 360.0;

    free1int(count);
    return axm;
}

float stddev(float* a, int n, float avg)
{
    int i;
    float diff;
    float asum = 0.0;
    for (i=0; i<n; ++i) {
        diff = a[i] - avg;
        if (ABS(diff) > 180.0) diff = 360.0 - ABS(diff);
        asum += diff*diff;
    }
    return (n>1)? sqrtf(asum/n) : 0.0;
}


// rotate x y according to angle a
void Rotate(int ntr, int nt, int vsp, float* baseangle, float angle, float** x, float** y)
{
    int itr;  // loop counter

    for (itr=0; itr<ntr; ++itr) { // loop over traces
        if (vsp == 0 ) {
            Rotate2C(0, nt, 0, angle, x[itr], y[itr], x[itr], y[itr]);
        } else {
            float a = baseangle[itr] - angle;
            Rotate2C(0, nt, 0, a, x[itr], y[itr], (vsp == 1)? x[itr] : y[itr], (vsp == 1)? y[itr] : x[itr]);
        }
    }
}

void Rotate2C(int itmin, int itmax, int skip, float angle, float* x, float* y, float* x1, float* y1)
{
    int it;  // loop counter
    float xtmp, sina, cosa;

    sina = sin(angle*PI/180.0);
    cosa = cos(angle*PI/180.0);

    for (it=itmin; it<=itmax; ++it) { // loop over samples
        if (skip && (x[it] == 0.0 || y[it] == 0.0)) {
            x1[it - itmin] = 0.0;
            y1[it - itmin] = 0.0;
            continue;
        }
        xtmp = cosa*x[it] + sina*y[it];
        y1[it - itmin] = -sina*x[it] + cosa*y[it];
        x1[it - itmin] = xtmp;
    }
    return;
}


float calcRMS(int nt, float* data)
{
    float sum = 0.0;
    int it, nc = 0;
    for (it = 0; it < nt; ++it ) {
        if (data[it] != 0.0 ) {
            ++nc;
            sum += data[it]*data[it];
        }
    }
    return (nc == 0)? 0.0 : sqrt(sum/nc);
}

float calcMax(int nt, float* data)
{
    float max = 0;
    int it;
    for (it = 0; it < nt; ++it ) {
        if (data[it] != 0.0 ) {
            if ( ABS(data[it]) > max) max = ABS(data[it]);
        }
    }
    return max;
}

/*
 *  This Quickselect routine is based on the algorithm described in
 *  "Numerical recipes in C", Second Edition,
 *  Cambridge University Press, 1992, Section 8.5, ISBN 0-521-43108-5
 *  This code by Nicolas Devillard - 1998. Public domain.
 */

#define ELEM_SWAP(a,b) { register float t=(a);(a)=(b);(b)=t; }

float quick_select(float *arr, int n)
{
    int low, high ;
    int median;
    int middle, ll, hh;

    low = 0 ; high = n-1 ; median = (low + high) / 2;
    for (;;) {
        if (high <= low) /* One element only */
            return arr[median] ;

        if (high == low + 1) {  /* Two elements only */
            if (arr[low] > arr[high])
                ELEM_SWAP(arr[low], arr[high]) ;
            return arr[median] ;
        }

		/* Find median of low, middle and high items; swap into position low */
		middle = (low + high) / 2;
		if (arr[middle] > arr[high])    ELEM_SWAP(arr[middle], arr[high]) ;
		if (arr[low] > arr[high])       ELEM_SWAP(arr[low], arr[high]) ;
		if (arr[middle] > arr[low])     ELEM_SWAP(arr[middle], arr[low]) ;

		/* Swap low item (now in position middle) into position (low+1) */
		ELEM_SWAP(arr[middle], arr[low+1]) ;

		/* Nibble from each end towards middle, swapping items when stuck */
		ll = low + 1;
		hh = high;
		for (;;) {
		    do ll++; while (arr[low] > arr[ll]) ;
		    do hh--; while (arr[hh]  > arr[low]) ;

		    if (hh < ll)
		    break;

		    ELEM_SWAP(arr[ll], arr[hh]) ;
		}

		/* Swap middle item (in position low) back into correct position */
		ELEM_SWAP(arr[low], arr[hh]) ;

		/* Re-set active partition */
		if (hh <= median) low = ll;
		if (hh >= median) high = hh - 1;
	}

    return (n%2)? arr[median] : 0.5*(arr[median] + arr[median + 1]);
}

#undef ELEM_SWAP
