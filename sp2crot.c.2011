/* Copyright (c) READ Well Services, 2010.*/
/* All rights reserved.                       */

/* SPCOMPROT v. 1.0 written by Sanyu Ye */


#include <cwp.h>
#include <su.h>
#include <header.h>
#include <segy.h>
#include <segyhdr.h>

/*********************** self documentation ******************************/
char *sdoc[] = {
"                                                                               ",
" SP2CROT  -  Compute and apply 2/3 component rotation/orientation for gimbaled ",
"               or fixed 3C geophone along diviated/horizontal well             ",
"                                                                               ",
"   sp2crot <stdin >stdout [options]                                            ",
"                                                                               ",
" Optional Parameters:                                                          ",
"                                                                               ",
"   key=cdpt      receiver gather sort key                                      ",
"   nxmax=512     max. number of shotpoints/traces for a component expected in a gather",
"                                                                               ",
"   nc=3          number of input components in order [H,] C3, C2 and C1, trace by trace",
"                 for VSP in order Z, H1/E, H2/N                                ",
"                 =4 for OBC Hydrophone(H), Vertical(Z), Inline(X) and Crossline(Y)",
"                                                                               ",
"   pol=1,1,1     polarities of C3/Z, C2/X/H1/E, C1/Y/H2/N                      ",
"                                                                               ",
"   axis=-3       rotation axis, count backward from last component             ",
"                 =-3 rotate along C3 (Z) from C1 (Y) towards C2 (X)            ",
"                 =-2 rotate along C2 (X) from C3 (Z) towards C1 (Y)            ",
"                 =-1 rotate along C1 (Y) from C2 (X) towards C3 (Z)            ",
"                                                                               ",
"   mode=0        =0 apply rotation, angle positive from C1 to C2 while along C3, and so further",
"                 =1 compute orientation/rotation angle                         ",
"                 =2 compute orientation and apply rotation                     ",
"                                                                               ",
"   base=0        =0  no base line, usually with mode=0 for just plain rotation ",
"                 =1  use azimuth receiver to source as base line (H1-H2 rotation)",
"                 =2  use inclination angle receiver to source,                 ",
"                     positive downward from horizontal(Z-H1 rotation)",
"                 =3  use dihedral angle (non-gimballed H1-H2 rotation on diviated well path)",
"                                                                               ",
"   a=otrav       keyword rotation angle is saved or fetched                    ",
"   azim=igc      keyword holding azimuth of well path at receiver              ",
"   incl=igi      keyword holding inclination of well path at receiver          ",
"   scale=0.01    scaling factor to convert angle in degrees (-180 ~ 180)       ",
"                                                                               ",
"   gdepth=gelev  keyword holding geophone depth, scaled by scalco as usual     ",
"   sdepth=sdepth keyword holding source depth, scaled by scalco as usual       ",
"                                                                               ",
" Parameters used to control applying rotation:                                 ",
"                                                                               ",
"   vsp=0         =-1 apply back projection onto ZEN for microseismic           ",
"                 =0  apply plain rotation without base line                    ",
"                 =1  rotate 1st component with max. energy                     ",
"                 =2  rotate 2nd component with max. energy, e.g. on H1         ",
"                 =3  rotate in TAU-P domain (Z-H1 rotation)                    ",
"   v=vevel [m/s] keyword containing velocity at receiver level for computing   ",
"                   rotation angle=asin(P*V) for vsp=3. P is fetched from tr.fx ",
"                                                                               ",
" Parameters used to determine orientation angle of first of two components: 	",
"                                                                               ",
"   t0=1.0  [s]   time line peaks of first arrivals are aligned on              ",
"                 i.e. FTB for VSP, first positive peak for OBC data            ",
"   t1=0.98 [s]   start of time window to determine rotation angles             ",
"                 should be set possibly close to onset of first arrivals       ",
"   t2=1.04 [s]   end of time window to determine rotation angle                ",
"                                                                               ",
"   da=0.5 [deg]  increment of rotation angle                                   ",
"   as=6.0 [deg]  angle (size) of sector to compute median value of orientation ",
"                                                                               ",
"   verbose=0     >0 output info                                                ",
"                                                                               ",
" Note:                                                                         ",
"   C1, C2, C3 or H2, H1, Z must build a right hand Cartesian coordinate system.",
"   For OBC input data must be sorted by hydrophone (H), if present, vertical (Z),",
"   inline (X) and crossline (Y) while for VSP in Z, H1/E, H2/N.                ",
"   Z (C3) axis is positive downwards, so the H1/E (inline) component that normally",
"   coincides with surface X axis is treated by this program as y (C2) internally",
"   while surface Y i.e. H2/N (crossline) as x (C1).                            ",
"   If only 2 components input, first trace is considered as C2.                ",
"   In case of multiple sources in a gather, distribution of determined orientation",
"   angles is computed. The sector with highest concentration and its two neighbouring",
"   sectors are used to determine the median value.                             ",
"   The program compute rms amplitude of the given window while rotate from first",
"   (x) to second axis (y). The orientation of x/C1/N is determined separately by",
"   max energy on x, y and ratio y/x. Normally all three results should give similar,",
"   values.                                                                     ",
"   The orientation angles determined by individual shot are stored in fx,fy,fz ",
"   while their median values in dx,dy,dz. In addition the median value of x is ",
"   stored in keyword specified by a=key. The orientation angles determined here",
"   refer to the azimuthal angle of component C1 (N/Y/H2 on surface). To project",
"   back C1/C2 to N/E as for microseismic study option vsp=-1 should be selected.",
"   Reversedly, in plain rotation mode (mode=0 vsp=0), C1/C2 will be rotated    ",
"   clockwise by an angle fetched from keyword as set by parameter a=keyword.   ",
"   For deviated or even horizontal well with non-gimbaled geophone the C3/Z is ",
"   refered to the inline component along well path. The azimuth and inclination",
"   of well path must be loaded in the keywords specified by (azim= and incl=). ",
"   Note the inclination is computed from horizontal, positive downward, rather ",
"   than the diviation of well from vertical as usually given for well path. To ",
"   enable 2C rotation analysis along Z (well path), two planes are constructed:",
"   A vertical plane through the well path is used as reference plane, another one",
"   through shotpoint and the same well path. The angle between these two planes",
"   is called dihedral angle and used as base angle. The angle determined by 2C ",
"   rotation analysis is refered to the vertical plane instead the North for azimuth.",
"   The orientations (azimuth/inclination) of C1/C2/C3 are stored in keyword fy/dy,",
"   fx/dx and fz/dz. If the rotation/orientation is applied, the output traces  ",
"   C3/C2/C1 correspond to Z/E/N (Z positive downward or along the well).       ",
"   Polarities of C3/C2/C1 can be corrected on the fly by parameter (pol=) before",
"   rotation analysis/application. Only in case of deviated well (base=3) the   ",
"   polarity of component Z is checked and warning given if it does not correspond",
"   its naturally recorded.                                                     ",
"   FTB must be strictly aligned at same level (t0=) before rotation analysis.  ",
"                                                                               ",
" Examples:                                                                     ",
" 1. align FTB at 1 sec and compute orientation angle of H2 for VSP             ",
" suchw key1=tstat key2=gwdep b=0.1 a=-1000 < gimbaledZH1H2.su |\\",
" sustatic hdrs=1 |\\",
" sp2crot mode=2 nc=3 axis=-3 vsp=2 key=gdel > ZRT.su",
"                                                                               ",
" 2. load azimuth/inclination for well path before analysis/application         ",
" sushw match=offset key=minute,sec infile=azim-incl.tbl < ZXY.su |\\",
" sp2crot mode=2 nc=3 axis=-3 key=offset base=3 > ZEN.su",
"                                                                               ",
"                                                                               ",
" Version 2.1.0 last modified  Dec. 2011 by Sanyu Ye                            ",
NULL};

/* Credits:
 *	Sanyu Ye: READ Well Services, May. 2010
 */
/**************** end self doc *******************************************/

// forward declaration
float calcRot(int ntr, int itftb, int itmin, int itmax, float da,
               float* baseangle, float** x, float** y, float** angles);
float quick_select(float *arr, int n);
void Rotate(const int ntr, const int nt, const int vsp, const float* baseangle, const float angle, float** x, float** y);
void Rotate2C(int itmin, int itmax, int skip, float angle, float* x, float* y, float* x1, float* y1);
float calcRMS(int nt, float* data);
float getMedianAngle(int ntr, float* ax, float alimit, float* stddiv, int* n);
float stddev(float* a, int n, float avg);
float calcDihedral(const float x, const float y, const float z, const float azim, const float incl, float* zPol);
void calc3COrient(const float azim, const float incl, const float a3, float* azim3c, float* incl3c);
void Project3C(const int ntr, const int itmin, const int itmax, const float* azim, const float* incl, float** x, float** y, float** z);

int verbose;		/* =0 no info, >0 output info  */

int main(int argc, char **argv) {
    cwp_String key, key_a, key_g, key_s, key_az, key_in, key_v;           /* header key word from segy.h		*/
    cwp_String type, type_a, type_g, type_s, type_az, type_in, type_v;      /* type of key				*/
    Value val, valnew, vala;                                /* value of key			*/
    int index, index_a, index_g, index_s, index_az, index_in, index_v;        /* index of key				*/
    int nt, it, itftb, itmin, itmax;       /* nums amps as int			*/
    int axis, xaxis, yaxis, zaxis, base;
    int nc, nxmax;                     /* number of components			*/
    int nsegy;                  /* length bytes read for segy trace	*/
    int mode, vsp;
    float a, asector, da, azim, incl;                    /* rotation angle computed or applied   */
    float t0, t1, t2, dt, scale;                /* input trace px py header values */
    float axm, aym, arm, stddvax, stddvay, stddvar;
    float azim3c[3], incl3c[3], pol[3];   /* orientation angle computed for x/y/z (N/E/Z-downward) in degrees (-180 - 180)   */
    float v, pv;
    int naxm, naym, narm;
    int i, itr, ntr, nsrc, ngather, total;
    segy tr, outtr;

    
    /* Initialize */
    initargs(argc, argv);
    requestdoc(0);

    if (!getparint("verbose", &verbose)) verbose=0;

    /* get keys */
    if (!getparstring("a", &key_a))	 key_a="otrav";
    type_a = hdtype(key_a);
    index_a = getindex(key_a);
    if (!getparstring("azim", &key_az))	 key_az="igc";
    type_az = hdtype(key_az);
    index_az = getindex(key_az);
    if (!getparstring("incl", &key_in))	 key_in="igi";
    type_in = hdtype(key_in);
    index_in = getindex(key_in);
    if (!getparstring("gdepth", &key_g)) key_g="gelev";
    type_g = hdtype(key_g);
    index_g = getindex(key_g);
    if (!getparstring("sdepth", &key_s)) key_s="sdepth";
    type_s = hdtype(key_s);
    index_s = getindex(key_s);
    if (!getparstring("v", &key_v)) key_v="wevel";
    type_v = hdtype(key_v);
    index_v = getindex(key_v);
    if (!getparstring("key", &key))	 key="cdpt";
    type = hdtype(key);
    index = getindex(key);

    if (!getparfloat("scale", &scale))  scale = 0.01;
    if (!getparfloat("as", &asector))   asector = 6.0;
    if (!getparfloat("da", &da))        da = 0.5;
    if (!getparint("nxmax", &nxmax))    nxmax = 512;

    if (!getparint("nc", &nc))        nc = 3;
    if (!getparint("mode", &mode))  mode = 0;
    if (!getparint("axis", &axis))  axis = -3;
    else {
        if (axis >=0 || axis < -3 || axis < -nc)
            err("invalid axis (=%d), should be between -1 and -3, count backwards", axis);
    }
    if (!getparint("base", &base)) {
        base = 0;
    } else {
        if ( base < 0 || base > 3 )
            err("invalid base line (=%d), should be none (=0) or azimuth (=1) or incident (=2) or dihedral angle (=3)", base);
    }
    if (!getparint("vsp", &vsp))     vsp = 0;
    if (vsp == 3) base = 0;  // reset base line angle to all zero
    if ( vsp < -1 || vsp > 3 )  err("invalid vsp option (-1 <= vsp=%d <= 3)", vsp);

    int n = countparval("pol");
    if ( n > 0 && n <= 3 ) {
        getparfloat("pol", pol);
        for (i = n; i < 3; ++i) pol[i] = pol[n-1];
    }
    else {
        {pol[0] = 1.0; pol[1] = 1.0; pol[2] = 1.0;}
    }

    // find out component index corresponding to x and y axis
    if (nc == 2) {
        xaxis = 1;
        yaxis = 0;
    } else {
        xaxis = nc + axis - 1;
        yaxis = nc + axis - 2;
        zaxis = nc + axis - 3;
        if (xaxis < nc - 3) xaxis += nc;
        if (yaxis < nc - 3) yaxis += nc;
        if (zaxis < nc - 3) zaxis += nc;
    }

    /* get first trace */
    if ( (nsegy=gettr(&tr)) < HDRBYTES) err("can't get first trace");
    gethval(&tr, index, &val);

    dt = ((double) tr.dt) / 1000000.0;
    nt = tr.ns;

    if (!getparfloat("t0", &t0)) t0 = 1.0;
    if (!getparfloat("t1", &t1)) t1 = 0.98;
    if (!getparfloat("t2", &t2)) t2 = 1.04;
    itftb = NINT(t0 / dt);
    itmin = NINT(t1 / dt);
    itmax = NINT(t2 / dt);
    if (mode > 0) { // Check time gating values for analysis mode
        if (itmin < 0)
            err("itmin=%d should be positive", itmin);
        if (itftb < itmin)
            err("t0 %5.3f should be larger than t1 %5.3f", t0, t1);
        if (itmin > itmax)
            err("itmin=%d, itmax=%d conflict", itmin, itmax);
        if (tr.ns <= itmax)
            err("tr.ns=%d, itmax=%d window cannot extend over the trace length", tr.ns, itmax);
    }
    
    segyhdr** hdrs = (segyhdr **) ealloc2(nxmax, nc, HDRBYTES);
    float***  indata = ealloc3float(nt, nxmax, nc);
    float*** outdata = ealloc3float(nt, nxmax, nc);
    float** baseangle = ealloc2float(nxmax, 4);
    float** angles = ealloc2float(nxmax, 3);
    float*  zPol = ealloc1float(nxmax);
    
    // reset with zero
    memset(*hdrs, 0, nc * nxmax * HDRBYTES);
    memset( **indata, 0, nc * nxmax * nt * FSIZE);
    memset(**outdata, 0, nc * nxmax * nt * FSIZE);
    memset(*baseangle, 0, 4 * nxmax * FSIZE);
    memset(*angles, 0, 3 * nxmax * FSIZE);
    memset(zPol, 0, nxmax * FSIZE);

    /* Read headers and data while getting a count */
    int eof = 0;
    ngather = ntr = total = 0;
    do {
        if (nsegy > HDRBYTES) gethval(&tr, index, &valnew);
        else eof = 1; //END_OF_FILE
        if (nsegy > HDRBYTES && !valcmp(type, val, valnew)) { /* same key and more data*/
            if (ntr > nc*(nxmax - 1)) err("\nNumber of traces exceeding nxmax=%d\n", nxmax);
            int isrc = ntr/nc;
            int icmp = ntr%nc;
            memcpy(&hdrs[icmp][isrc], &tr, HDRBYTES);
            for (it = 0; it < nt; ++it) indata[icmp][isrc][it] = pol[icmp]*tr.data[it];
            if (!icmp) {
                float y = tr.sx - tr.gx;  // internal coordinate x-N, y-E, z-Z downwards
                float x = tr.sy - tr.gy;
                float dist = sqrtf(x*x + y*y);
                gethval(&tr, index_g, &vala);
                float zg = vtoi(type_g, vala);
                gethval(&tr, index_s, &vala);
                float zs = vtoi(type_s, vala);
                float z = zs - zg;
                baseangle[1][isrc] = 180/PI*atan2(y, x); // recerver to source azimuth
                baseangle[2][isrc] = 180/PI*atan2(z, dist); // // recerver to source inclination
                if (base == 3) {
                    gethval(&tr, index_az, &vala);
                    azim = scale*vtof(type_az, vala);
                    gethval(&tr, index_in, &vala);
                    incl = scale*vtof(type_in, vala);
                    baseangle[3][isrc] = calcDihedral(x, y, z, azim, incl, &zPol[isrc]);
                }
            }
            ++ntr;
            val = valnew;
        } else { // new gather or END_OF_FILE
            ++ngather;
            if (verbose>1) warn(" Processing %d traces %d-th gather (%s=%d) ...", ntr, ngather, key, vtoi(type, val));
            if (ntr%nc) err(" number of traces not multiple of number of components for %d-th gather (%s=%d)",
                    ntr, ngather, key, vtoi(type, val));

            nsrc = ntr/nc;
            total += ntr;

            stddvax = stddvay = stddvar = 0.0;
            if ( mode == 0 ) { // fetch angle
                if (base == 3) {
                    azim3c[2] = hdrs[0][0].fz;
                    incl3c[2] = hdrs[0][0].dz;
                    azim3c[1] = hdrs[0][0].fy;
                    incl3c[1] = hdrs[0][0].dy;
                    azim3c[0] = hdrs[0][0].fx;
                    incl3c[0] = hdrs[0][0].dx;
                } else if (vsp == 3) { // compute angle from ray parameter p=tr.fx and velocity contained in key_v
                    gethval((segy*) hdrs[0], index_v, &vala);
                    v = 0.001*vtod(type_v, vala);  //  convert to km/s
                    pv = -tr.fx*v;  // nagate to account for natural polarity of X (positive on -X or -P side)
                    if ( ABS(pv) > 1.0) {
                        if (verbose) warn (" rotation angle reset to 90 degree for P=%8.6f V=%4.0f of %d-th gather (%s=%d)",
                                tr.fx, 1000.0*v, ngather, key, vtoi(type, val));
                        pv = (pv > 0)? 1.0 : -1.0;
                    }
                    a = asinf(pv) * 180.0 / PI;
                    vala.h = (short) NINT(a/scale);
                } else {
                    gethval((segy*) hdrs[0], index_a, &vala);
                    a = vtod(type_a, vala)*scale;
                }
            } else {
                // check z polarity
                if (nc > 2 && base == 3) {
                    int nFalsePol = 0;
                    for (i = 0; i < nsrc; ++i) {
                        if (indata[zaxis][i][itftb]*zPol[i] < 0.0) ++nFalsePol;
                    }
                    if (verbose > 0) warn("  %d out of total %d  traces of Z (inline to well) have wrong apparent polarity", nFalsePol, nsrc);
                }
                // do calculate rotation angle
                calcRot(nsrc, itftb, itmin, itmax, da, baseangle[base], indata[xaxis], indata[yaxis], angles);
                a = axm = getMedianAngle(nsrc, angles[0], asector, &stddvax, &naxm);
                aym = getMedianAngle(nsrc, angles[1], asector, &stddvay, &naym);
                arm = getMedianAngle(nsrc, angles[2], asector, &stddvar, &narm);
                stddvax = stddev(angles[0], nsrc, axm);
                stddvay = stddev(angles[1], nsrc, aym);
                stddvar = stddev(angles[2], nsrc, arm);

                vala.h = (short) NINT(a/scale);
                //vala.i = (int) (a/scale);
                if (verbose > 1) {
                    for (i = 0; i < nsrc; ++i) {
                        warn("  Baselines for source %3d : Azimuth=%4.2f   Inclination=%4.2f   Dihedral=%4.2f", \
                            i+1, baseangle[1][i], baseangle[2][i], (base == 3)? baseangle[3][i] : 0.0);
                    }
                }
                if (verbose>0) warn(" Orientation/Azimuth determined by rms C1, C2 and C2/C1: %6.5f %6.5f %6.5f ",
                        axm, aym, arm);
                if (verbose) warn(" Orientation/Azimuth of C%d = %.5f (degrees) for %d-th gather (%s=%d)",
                        nc - xaxis, a, ngather, key, vtoi(type, val));

                if (base == 3) { // for dipping well
                    if (verbose) warn("  relative to well track orientation Azimuth = %.5f , Inclination = %.5f (degrees)", azim, incl);
                    calc3COrient(azim, incl, a, azim3c, incl3c);
                    if (verbose) warn("  Azimuth/Inclination N/C1/Y=%3.1f/%3.1f  E/C2/X=%3.1f/%3.1f  C3/Z=%3.1f/%3.1f\n",
                            azim3c[1], incl3c[1], azim3c[0], incl3c[0], azim3c[2], incl3c[2]);
                }
            }

            if (mode == 0 || mode == 2) { // apply rotation
                if (base == 3) {
                    Project3C(nsrc, 0, nt - 1, azim3c, incl3c, indata[xaxis], indata[yaxis], indata[zaxis]);
                } else {
                    Rotate(nsrc, nt, vsp, baseangle[base], a, indata[xaxis], indata[yaxis]);
                }
            }

            for (itr = 0; itr < nsrc; ++itr) {
                for (i = 0; i < nc; ++i) {
                    memcpy(&outtr, &hdrs[i][itr], HDRBYTES);
                    memcpy(outtr.data, indata[i][itr], FSIZE * nt);
                    if (mode > 0) {
                        outtr.gaps    = NINT(100.0*baseangle[base][itr]);
                        outtr.grnors  = NINT(100.0*angles[0][itr]);
                        outtr.grnofr  = NINT(100.0*axm);
                        outtr.grnlof  = NINT(100.0*stddvax);
                        if (base == 3) {
                            outtr.fz = azim3c[2];
                            outtr.dz = incl3c[2];
                            outtr.fy = azim3c[1];
                            outtr.dy = incl3c[1];
                            outtr.fx = azim3c[0];
                            outtr.dx = incl3c[0];
                        } else {
                            outtr.fx = axm;
                            outtr.dx = stddvax;
                            outtr.fy = angles[0][itr];
                            outtr.dy = nsrc;
                            outtr.fz = baseangle[1][itr];
                            outtr.dz = baseangle[2][itr];
                        }
                        puthval(&outtr, index_a, &vala);
                    } else if (vsp == 3) {
                        puthval(&outtr, index_a, &vala);
                    }
                    puttr(&outtr);
                }
            }
            
            val = valnew;
            // reset output data
            memset(**indata, 0, nc * nxmax * nt * FSIZE);
            memset(*hdrs, 0, nc * nxmax * HDRBYTES);
            memset(*baseangle, 0, 4 * nxmax * FSIZE);
            memset(*angles, 0, 3 * nxmax * FSIZE);
            memset(zPol, 0, nxmax * FSIZE);
            ntr = 0;
            continue;
        }
        nsegy = gettr(&tr);
    } while (!eof);

    if (verbose) warn(" Totally %d traces for each of %d compomnents are processed", total/nc, nc);
    
    return(CWP_Exit());
}

float calcRot(int nsrc, int itftb, int itmin, int itmax, float da, float* baseangle, float** x, float** y, float** angles)
{
    int itr;
    float a, axftb, ayftb, arftb;
    float xaa, xab, yaa, yab, raa, rab;
    float xrms, yrms, ratio;

    float* ax = ealloc1float(nsrc);
    float* ay = ealloc1float(nsrc);
    float* ar = ealloc1float(nsrc);
    float* xrmsmax = ealloc1float(nsrc);
    float* yrmsmax = ealloc1float(nsrc);
    float* rrmsmax = ealloc1float(nsrc);
    memset(ax, 0, nsrc*FSIZE);
    memset(ay, 0, nsrc*FSIZE);
    memset(ar, 0, nsrc*FSIZE);
    memset(xrmsmax, 0, nsrc*FSIZE);
    memset(yrmsmax, 0, nsrc*FSIZE);
    memset(rrmsmax, 0, nsrc*FSIZE);

    int nt = itmax - itmin + 1;
    float* x1 = ealloc1float(nt);
    float* y1 = ealloc1float(nt);

    xaa = xab = yaa = yab = raa = rab = 0.0;
    for (itr=0; itr<nsrc; ++itr) {
        for (a = 0; a <= 180.0; a += da) {
            Rotate2C(itmin, itmax, 1, a, x[itr], y[itr], x1, y1);
            xrms = calcRMS(nt, x1);
            yrms = calcRMS(nt, y1);
            ratio = (xrms == 0.0)? 0.0 : yrms / xrms;
            if (xrms > xrmsmax[itr] ) {
                axftb = x1[itftb-itmin];
                ax[itr] = baseangle[itr] - a + 180;
                xrmsmax[itr] = xrms;
            }
            if (yrms > yrmsmax[itr] ) {
                ayftb = y1[itftb-itmin];
                ay[itr] = baseangle[itr] - a + 90.0;
                yrmsmax[itr] = yrms;
            }
            if (ratio > rrmsmax[itr] ) {
                arftb = y1[itftb-itmin];
                ar[itr] = baseangle[itr] - a + 90.0;
                rrmsmax[itr] = ratio;
            }
        }
        
        if (axftb < 0) ax[itr] -= 180.0;
        if (ax[itr] >  180) ax[itr] -= 360.0;
        if (ax[itr] < -180) ax[itr] += 360.0;
        if (ayftb < 0) ay[itr] -= 180.0;
        if (ay[itr] >  180) ay[itr] -= 360.0;
        if (ay[itr] < -180) ay[itr] += 360.0;
        if (arftb < 0) ar[itr] -= 180.0;
        if (ar[itr] >  180) ar[itr] -= 360.0;
        if (ar[itr] < -180) ar[itr] += 360.0;
       
        angles[0][itr] = ax[itr];
        angles[1][itr] = ay[itr];
        angles[2][itr] = ar[itr];
    }

    free1float(x1);
    free1float(y1);
    free1float(ax);
    free1float(ay);
    free1float(ar);
    free1float(xrmsmax);
    free1float(yrmsmax);
    free1float(rrmsmax);

    return 0.0;
}


float getMedianAngle(int ntr, float* ax, float alimit, float* stddiv, int* n)
{
    int i, itr, na = 0, imaxsector = 0, maxcount = 0 ;
    int nsector = 360/alimit;
    int* count = ealloc1int(nsector);
    memset(count, 0, nsector*sizeof(int));
    for (itr=0; itr<ntr; ++itr) {
        //if (ax[itr] == 0.0) continue;  // exclude hard zero, probably not determined value
        i = (int)((ax[itr] + 180.0)/alimit);
        if (i < 0 || i > nsector - 1) continue;
        //if (i < 0) i += nsector;
        //if (i > nsector -1) i -= nsector;
        count[i]++;
    }
    for (i = 0; i < nsector; ++i) {
        if (count[i] > maxcount) {
            imaxsector = i;
            maxcount = count[i];
        }
    }
    float amin = (imaxsector - 1) * alimit - 180.0;
    float amax = (imaxsector + 2) * alimit - 180.0;
    for (itr=0; itr<ntr; ++itr) {
        if (ax[itr] == 0.0) continue;  // exclude hard zero, probably not determined value
        if (imaxsector == nsector - 1 && ax[itr] < -180.0 + alimit) ax[itr] += 360.0;  // -180 ~ -180 + 6
        if (imaxsector == 0 && ax[itr] >  180.0 - alimit) ax[itr] -= 360.0;            // 180 - 6 ~ 180
        if ( ax[itr] < amax && ax[itr] > amin ) ax[na++] = ax[itr];
    }
    if (na == 0) {
        warn("no non-hardzero present, return 0");
        return 0.0;
    }

    float axm = quick_select(ax, na);
    if (stddiv) *stddiv = stddev(ax, na, axm);
    if (n) *n = na;

    if (axm >  180.0) axm -= 360.0;
    if (axm < -180.0) axm += 360.0;

    free1int(count);
    return axm;
}

float stddev(float* a, int n, float avg)
{
    int i;
    float diff;
    float asum = 0.0;
    for (i=0; i<n; ++i) {
        diff = a[i] - avg;
        if (ABS(diff) > 180.0) diff = 360.0 - ABS(diff);
        asum += diff*diff;
    }
    return (n>1)? sqrtf(asum/n) : 0.0;
}


// rotate x y according to angle a
void Rotate(const int ntr, const int nt, const int vsp, const float* baseangle, const float angle, float** x, float** y)
{
    int itr;  // loop counter
    float a = angle;

    for (itr=0; itr<ntr; ++itr) { // loop over traces
        if (vsp == -1) {
            a = -angle;
        } else if (vsp == 1) {
            a = 180.0 + baseangle[itr] - angle;
        } else if (vsp == 2) {
            a =  90.0 + baseangle[itr] - angle;
        }
        Rotate2C(0, nt, 0, a, x[itr], y[itr], x[itr], y[itr]);
    }
}

void Rotate2C(int itmin, int itmax, int skip, float angle, float* x, float* y, float* x1, float* y1)
// x1/y1  rotate  anticlockwise to x/y
{
    int it;  // loop counter
    float xtmp, sina, cosa;

    sina = sin(angle*PI/180.0);
    cosa = cos(angle*PI/180.0);

    for (it=itmin; it<=itmax; ++it) { // loop over samples
        if (skip && (x[it] == 0.0 && y[it] == 0.0)) {
            x1[it - itmin] = 0.0;
            y1[it - itmin] = 0.0;
            continue;
        }
        xtmp = cosa*x[it] + sina*y[it];
        y1[it - itmin] = -sina*x[it] + cosa*y[it];
        x1[it - itmin] = xtmp;
    }
    return;
}

float calcDihedral(const float x, const float y, const float z, const float azim, const float incl, float* zPol)
{
    float ax, ay, bx, by, bz, angle;
    float cx, cy, cz, dx, dy, dz, d;
    float cx2, cy2, cz2, cc, zz;
    
    // calc directional cos a for vertical plane along well path
    // ax*x + ay*y + az*z + d1 = 0

    ay =  cosf(azim*PI/180.0);
    ax = -sinf(azim*PI/180.0);
    // c1 = d1 = 0.0;

    // calc directional cos for well path (line)
    cx = cosf(azim*PI/180.0)*cosf(incl*PI/180.0);
    cy = sinf(azim*PI/180.0)*cosf(incl*PI/180.0);
    cz = sinf(incl*PI/180.0);

    // calc directional cos for receiver to source (line)
    d = sqrtf(x*x + y*y + z*z);
    dx = x/d;
    dy = y/d;
    dz = z/d;

    // calc dot product of reversed ray (r2s) and well track
    zz = dx*cx + dy*cy + dz*cz;
    *zPol = (zz > 0.0)? -1.0 : 1.0;

    // calc normal directional cos b for plane through source and well path
    // b = c x d = | (c2d3 - c3b2)  (c3d1 - c1d3)  (c1d2 - c2d1) |   cross product

    bx = cy*dz - cz*dy;
    by = cz*dx - cx*dz;
    bz = cx*dy - cy*dx;
    // should be d x c = - c x d
    //bx = -bx;
    //by = -by;
    //bz = -bz;

    // dehydral angle
    angle = acosf((ax*bx + ay*by)/sqrt(bx*bx + by*by + bz*bz));

    // the angle is smaller 180, use cross product to figure out rotation sense
    // c2 = a x b
    cx2 = ay*bz;
    cy2 = -ax*bz;
    cz2 = ax*by - ay*bx;

    cc = cx*cx2 + cy*cy2 + cz*cz2;

    if (cc < 0.0) angle = -angle;

    return angle*180.0/PI;
}

float calcRMS(int nt, float* data)
{
    float sum = 0.0;
    int it, nc = 0;
    for (it = 0; it < nt; ++it ) {
        if (data[it] != 0.0 ) {
            ++nc;
            sum += data[it]*data[it];
        }
    }
    return (nc == 0)? 0.0 : sqrt(sum/nc);
}

float calcMax(int nt, float* data)
{
    float max = 0;
    int it;
    for (it = 0; it < nt; ++it ) {
        if (data[it] != 0.0 ) {
            if ( ABS(data[it]) > max) max = ABS(data[it]);
        }
    }
    return max;
}

void calc3COrient(const float azim, const float incl, const float a3, float* azim3c, float* incl3c)
{
    // a3 last rotation angle along z (downwards but dip with an angle=a2 to vertical)
    // a2 second rotation along y (X for data) from z (vertical downwards)
    // a1 first rotation along z (vertical downwards) the azimuth of well track at receiver

    //  x   | cosa1  -sina3    0 | | cosa2   0   sina2 | | cosa3  -sina3   0  | | x3 |
    //  y = | sina1   cosa1    0 |*|   0     1     0   |*| sina3   cosa3   0  |*| y2 |
    //  z   |   0       0      1 | | -sina2  0   cosa2 | |   0       0     1  | | z1 |

    //  x   | cosa1cosi1   cosa2cosi2   cosa3cosi3 | | x' |
    //  y = | sina1cosi1   sina2cosi2   sina3cosi3 |*| y' |
    //  z   |    sini1        sini2        sini3   | | z' |


    // a1 = azim  well track azimuth, a2 = 90 - incl  (incl = well track inclination)
    float a1 = azim;
    float a2= 90.0 - incl;

    float sina1 = sinf(a1*PI/180.0);
    float cosa1 = cosf(a1*PI/180.0);
    float sina2 = sinf(a2*PI/180.0);
    float cosa2 = cosf(a2*PI/180.0);
    float sina3 = sinf(a3*PI/180.0);
    float cosa3 = cosf(a3*PI/180.0);

    azim3c[2] = azim;  // z comp, positive downwards
    incl3c[2] = incl;   // inline (to well) inclination, equal 90 - angle (diviation of well from vertical)

    azim3c[1] = atan2f(sina1*cosa2*cosa3 + cosa1*sina3 , cosa1*cosa2*cosa3 - sina1*sina3)*180.0/PI;    // N/X/y, X in internal but y on surface coord. system
    incl3c[1] = asinf(-cosa3*sina2)*180.0/PI;

    azim3c[0] = atan2f(-sina1*cosa2*sina3 + cosa1*cosa3 , -cosa1*cosa2*sina3 - sina1*cosa3)*180.0/PI;  // E/Y/x, Y in internal but x on surface coord. system
    incl3c[0] = asinf(sina2*sina3)*180.0/PI;    

    return;
}

void Project3C(const int ntr, const int itmin, const int itmax, const float* azim, const float* incl, float** x, float** y, float** z)
{
    //  x   | cosa1cosi1   cosa2cosi2   cosa3cosi3 | | x' |
    //  y = | sina1cosi1   sina2cosi2   sina3cosi3 |*| y' |
    //  z   |    sini1        sini2        sini3   | | z' |

    int it, itr;
    float xtmp, ytmp, ztmp;

    float sina1 = sinf(azim[1]*PI/180.0);
    float cosa1 = cosf(azim[1]*PI/180.0);
    float sini1 = sinf(incl[1]*PI/180.0);
    float cosi1 = cosf(incl[1]*PI/180.0);
    float sina2 = sinf(azim[0]*PI/180.0);
    float cosa2 = cosf(azim[0]*PI/180.0);
    float sini2 = sinf(incl[0]*PI/180.0);
    float cosi2 = cosf(incl[0]*PI/180.0);
    float sina3 = sinf(azim[2]*PI/180.0);
    float cosa3 = cosf(azim[2]*PI/180.0);
    float sini3 = sinf(incl[2]*PI/180.0);
    float cosi3 = cosf(incl[2]*PI/180.0);

    for (itr=0; itr<ntr; ++itr) {
        for (it=itmin; it<=itmax; ++it) {
            xtmp = cosa1*cosi1*x[itr][it] + cosa2*cosi2*y[itr][it] + cosa3*cosi3*z[itr][it];
            ytmp = sina1*cosi1*x[itr][it] + sina2*cosi2*y[itr][it] + sina3*cosi3*z[itr][it];
            ztmp = sini1*x[itr][it] + sini2*y[itr][it] + sini3*z[itr][it];
            x[itr][it] = xtmp;
            y[itr][it] = ytmp;
            z[itr][it] = ztmp;
        }
    }
    return;
}


/*
 *  This Quickselect routine is based on the algorithm described in
 *  "Numerical recipes in C", Second Edition,
 *  Cambridge University Press, 1992, Section 8.5, ISBN 0-521-43108-5
 *  This code by Nicolas Devillard - 1998. Public domain.
 */

#define ELEM_SWAP(a,b) { register float t=(a);(a)=(b);(b)=t; }

float quick_select(float *arr, int n)
{
    int low, high ;
    int median;
    int middle, ll, hh;

    low = 0 ; high = n-1 ; median = (low + high) / 2;
    for (;;) {
        if (high <= low) /* One element only */
            return arr[median] ;

        if (high == low + 1) {  /* Two elements only */
            if (arr[low] > arr[high])
                ELEM_SWAP(arr[low], arr[high]) ;
            return arr[median] ;
        }

		/* Find median of low, middle and high items; swap into position low */
		middle = (low + high) / 2;
		if (arr[middle] > arr[high])    ELEM_SWAP(arr[middle], arr[high]) ;
		if (arr[low] > arr[high])       ELEM_SWAP(arr[low], arr[high]) ;
		if (arr[middle] > arr[low])     ELEM_SWAP(arr[middle], arr[low]) ;

		/* Swap low item (now in position middle) into position (low+1) */
		ELEM_SWAP(arr[middle], arr[low+1]) ;

		/* Nibble from each end towards middle, swapping items when stuck */
		ll = low + 1;
		hh = high;
		for (;;) {
		    do ll++; while (arr[low] > arr[ll]) ;
		    do hh--; while (arr[hh]  > arr[low]) ;

		    if (hh < ll)
		    break;

		    ELEM_SWAP(arr[ll], arr[hh]) ;
		}

		/* Swap middle item (in position low) back into correct position */
		ELEM_SWAP(arr[low], arr[hh]) ;

		/* Re-set active partition */
		if (hh <= median) low = ll;
		if (hh >= median) high = hh - 1;
	}

    return (n%2)? arr[median] : 0.5*(arr[median] + arr[median + 1]);
}

#undef ELEM_SWAP
