/* Copyright (c) READ Well Services, 2010.*/
/* All rights reserved.                       */

/* SPCOMPROT v. 1.0 written by Sanyu Ye */


#include <cwp.h>
#include <su.h>
#include <header.h>
#include <segy.h>
#include <segyhdr.h>

/*********************** self documentation ******************************/
char *sdoc[] = {
"                                                                               ",
" SP3CROT - Compute and apply 3C orientation/projection for 4C OBC data         ",
"                                                                               ",
"   spcomprot <stdin >stdout [options]                                          ",
"                                                                               ",
" Optional Parameters:                                                          ",
"                                                                               ",
"   nc=3          number of input components in order [H,] C3, C2 and C1, trace by trace",
"                 =4 for OBC Hydrophone(H), Vertical(Z), Inline(X) and Crossline(Y)",
"                                                                               ",
"   mode=0        =0 apply projection with given orientation of 3C              ",
"                 =1 compute orientation/rotation angle                         ",
"                 =2 compute orientation and apply rotation/projection          ",
"                                                                               ",
"   key=cdpt      receiver gather sort key, used to compute angle               ",
"   nxmax=512     max. number of traces for a component expected in a gather    ",
"                                                                               ",
"   gdepth=gelev  keyword holding geophone depth, scaled by scalco as usual     ",
"   obcazim=hour  keyword holding cable azimuth, in 100th degrees (-180 ~ 180)  ",
"                                                                               ",
" Parameters used to determine orientation angles of 3 geophone component:      ",
"                                                                               ",
"   t0=1.0  [s]   time line peaks of first arrivals are aligned on              ",
"                 i.e. FTB for VSP, first positive peak for OBC data            ",
"   t1=0.992 [s]  start of time window to determine rotation angles             ",
"                 should be set possibly close to onset of first arrivals       ",
"   t2=1.040 [s]  end of time window to determine rotation angle                ",
"                                                                               ",
"   vw=1.48       P wave velocity of water                                      ",
"   vp=vw         P wave velocity of seafloor                                   ",
"                                                                               ",
"   aw=90,15,5    half width of search window for roll, tilt and azimuth        ",
"   da=1,0.5,0.5  corresponding increment of rotation angle                                   ",
"                                                                               ",
"   verbose=0     >0 output info                                                ",
"                                                                               ",
" Note:                                                                         ",
"   For details of algorithm see Olofsson et al. 2007 SEG extended abstract     ",
"   Determining 3C geophone orientation from a single shot.                     ",
"                                                                               ",
"   C1, C2, C3 must build a right hand Cartesian coordinate system. ",
"   Z (C3) axis is positive downwards, so the inline component that normally    ",
"   coincides with surface X axis is treated by this program as Y (C2) internally",
"   while surface Y as X (C1).                                                  ",
"   Input data must be shifted in the way that the FTBs are aligned at specified",
"   time (1 sec by defauft). The FTB vector is used to determined tilt and roll ",
"   of the cable stored in keyword minute and sec respectively. Azimuths of the ",
"   cable (Inline component) must be given in keyword specified by obcazim=     ",
"   (default =hour). The source-to-receiver azimuth and transmission angle at   ",
"   geophone are stored in year and day. Keywords grnnof, grnlof, grnons, gabs  ",
"   hold median tilt and roll and its respective std deviation when a gather has",
"   multiple sources. The orientation (azimuth and inclination) of individual   ",
"   component are stored in fx, dx, fy, dy and fy and dz                        ",
"                                                                               ",
" Major steps for determine 3C orientation:                                                                     ",
" 1. Calulate cable azimuth.",
" 2. Use hydrophone to determine FTB",
" 3. load FTB to geophones and aligned them, load azimuth                       ",
" spcomprot nc=3 axis=-3 key=gdel < input.su > output.su                        ",
"                                                                               ",
"                                                                               ",
"                                                                               ",
NULL};

/* Credits:
 *	Sanyu Ye: READ Well Services, May. 2010
 */
/**************** end self doc *******************************************/

// forward declaration
float calcRot(int ntr, int itftb, int itmin, int itmax, int na, float a0, float da,
               float* baseangle, float** x, float** y, float a[6]);
float quick_select(float *arr, int n);
void Rotate(int ntr, int nt, float angle, float** x, float** y);
void Rotate2C(int itmin, int itmax, int skip, float angle, float* x, float* y, float* x1, float* y1);
void Project3C(int ntr, int itmin, int itmax, float* azim, float* incl, float** x, float** y, float** z);
void Project1C(int itmin, int itmax, float azim, float incl, float* x, float* x1, float* y1, float* z1);
float calcRMS(int nt, float* data);
float getMedianAngle(int ntr, float* ax, float alimit);
float stddev(float* a, int n, float avg);
void calc3COrient(const float gamma, const float theta, const float phi, float* azim3c, float* incl3c);
void calc3C(const float azims2r, const float incident, const float azimx, float* tilt, float* roll, const float x, const float y, const float z);
void calcOrientations(int nsrc, int itftb, float* azims2r, float* incident, const float azim, float* tilt, float* roll,
                        float** iline, float** xline, float** z);

int verbose;		/* =0 no info, >0 output info  */

int main(int argc, char **argv) {
    cwp_String key, key_a, key_g;	/* header key word from segy.h		*/
    cwp_String type, type_a, type_g;    /* type of key				*/
    Value val, valnew, vala;                  /* value of key			*/
    int index, index_a, index_g;         /* index of key				*/
    int nt, itftb, itmin, itmax;       /* nums amps as int			*/
    int xaxis, yaxis, zaxis;
    int nc, nxmax;                     /* number of components			*/
    int nsegy;                  /* length bytes read for segy trace	*/
    int mode, na;
    float azim3c[3], incl3c[3], Azim, Tilt, Roll;                    /* rotation angle computed or applied   */
    float stddvTilt, stddvRoll;                    /* rotation angle computed or applied   */
    float aw[3], da[3];                    /* rotation angle computed or applied   */
    float vp, vw;                               /* P velocity for seafloor and sea water   */
    float t0, t1, t2, dt, scale;                /* input trace px py header values */
    int i, itr, isrc, ntr, ngather, total;
    segy tr, outtr;

    
    /* Initialize */
    initargs(argc, argv);
    requestdoc(0);

    if (!getparint("verbose", &verbose)) verbose=0;

    if (!getparstring("obcazim", &key_a)) key_a="hour";
    type_a = hdtype(key_a);
    index_a = getindex(key_a);
    if (!getparstring("gdepth", &key_g)) key_g="gelev";
    type_g = hdtype(key_g);
    index_g = getindex(key_g);
    if (!getparstring("key", &key))	 key="cdpt";
    type = hdtype(key);
    index = getindex(key);

    if (!getparfloat("vw", &vw)) vw = 1.48;
    if (!getparfloat("vp", &vp)) vp = vw;
    if (!getparfloat("scale", &scale)) scale = 0.01;
    if (!getparfloat("aw", aw))  {aw[0] = 90.0; aw[1] = 15.0; aw[2] = 3.0;}
    if (!getparfloat("da", da))  {da[0] = 1.0;  da[0] = 0.5;  da[2] = 0.5;}
    //if (!getparint("na", &na))      na = 180;
    if (!getparint("nxmax", &nxmax)) nxmax = 512;

    if (!getparint("nc", &nc))        nc = 4;
    if (!getparint("mode", &mode))  mode = 0;
    // find out component index corresponding to x and y axis
    xaxis = (nc == 4)? 3 : 2;
    yaxis = (nc == 4)? 2 : 1;
    zaxis = (nc == 4)? 1 : 0;

    /* get first trace */
    if ( (nsegy=gettr(&tr)) < HDRBYTES) err("can't get first trace");
    gethval(&tr, index, &val);

    dt = ((double) tr.dt) / 1000000.0;
    nt = tr.ns;

    if (!getparfloat("t1", &t1)) t0 = 1.0;
    if (!getparfloat("t1", &t1)) t1 = 0.992;
    if (!getparfloat("t2", &t2)) t2 = 1.040;
    itftb = NINT(t0 / dt);
    itmin = NINT(t1 / dt);
    itmax = NINT(t2 / dt);
    /* Check time gating values */
    if (itmin < 0)
        err("itmin=%d should be positive", itmin);
    if (itftb < itmin)
        err("t0 %5.3f should be larger than t1 %5.3f", t0, t1);
    if (itmin > itmax)
        err("itmin=%d, itmax=%d conflict", itmin, itmax);
    if (tr.ns <= itmax)
        err("tr.ns=%d, itmax=%d window cannot extend over the trace length", tr.ns, itmax);
    
    segyhdr** hdrs = (segyhdr **) ealloc2(nxmax, nc, HDRBYTES);
    float***  indata = ealloc3float(nt, nxmax, nc);
    float* azim = ealloc1float(nxmax);
    float* tilt = ealloc1float(nxmax);
    float* roll = ealloc1float(nxmax);
    float* azims2r = ealloc1float(nxmax);
    float* incident = ealloc1float(nxmax);
    
    memset(*hdrs, 0, nc * nxmax * HDRBYTES);
    memset( **indata, 0, nc * nxmax * nt * FSIZE);
    memset(azim, 0, nxmax * FSIZE);
    memset(tilt, 0, nxmax * FSIZE);
    memset(roll, 0, nxmax * FSIZE);
    memset(azims2r, 0, nxmax * FSIZE);
    memset(incident, 0, nxmax * FSIZE);

    /* Read headers and data while getting a count */
    int eof = 0;
    ngather = ntr = total = 0;
    do {
        if (nsegy > HDRBYTES) gethval(&tr, index, &valnew);
        else eof = 1; //END_OF_FILE
        if (nsegy > HDRBYTES && !valcmp(type, val, valnew)) { /* same key and more data*/
            if (ntr > nc*nxmax - 1) err("\nNumber of traces exceeding nxmax=%d\n", nxmax);
            memcpy(&hdrs[ntr%nc][ntr/nc], &tr, HDRBYTES);
            memcpy(indata[ntr%nc][ntr/nc], tr.data, FSIZE * nt);
            if (!(ntr%nc)) {
                isrc = ntr/nc;
                float x = tr.gx - tr.sx;
                float y = tr.gy - tr.sy;
                float dist = sqrtf(x*x + y*y);
                gethval(&tr, index_g, &vala);
                float z = vtoi(type_g, vala) - tr.sdepth;
                if ( !x && !y ) {
                    warn(" no azimuth can be calculated (x=0, y=0) for %d-th source of %d-th gather(%s=%d)",
                    isrc + 1, ngather, key, vtoi(type, val));
                } else {
                    float inci = atan2f(dist, z);
                    if (fabs(sinf(inci)) > vw/vp) {
                        warn(" total reflection for %d-th source (offset=%d) of %d-th gather(%s=%d)",
                        isrc + 1, tr.offset/(!tr.scalco ? 1 : ABS(tr.scalco)), ngather, key, vtoi(type, val));
                    } else {
                        azims2r[isrc] = 180/M_PI*atan2f(x, y);
                        incident[isrc] = 180/M_PI*asinf(sin(inci) * vp/vw);
                        gethval(&tr, index_a, &vala);
                        azim[isrc] = 0.01*vtoi(type_a, vala);  // OBC cable azimuth
                    }
                }
            }
            ++ntr;
            val = valnew;
        } else { // new gather or END_OF_FILE
            ++ngather;
            if (ntr%nc) err(" number of traces not multiple of number of components for %d-th gather (%s=%d)", ntr, ngather, key, vtoi(type, val));

            total += ntr;

            int nsrc = ntr/nc;
            if (verbose>1) warn("  processing %d traces a la %d component for %d-th gather (%s=%d)", nsrc, nc, ngather, key, vtoi(type, val));
            if ( mode == 0 ) { // fetch angle
                azim3c[2] = hdrs[0][0].fz;
                incl3c[2] = hdrs[0][0].dz;
                azim3c[1] = hdrs[0][0].fx;
                incl3c[1] = hdrs[0][0].dx;
                azim3c[0] = hdrs[0][0].fy;
                incl3c[0] = hdrs[0][0].dy;
            } else { // do calculate rotation angle
                calcOrientations(nsrc, itftb, azims2r, incident, azim[0], tilt, roll, indata[xaxis], indata[yaxis], indata[zaxis]);
                azim3c[0] = azim[0];
                Azim = azim[0];
                Tilt = tilt[0];
                Roll = roll[0];
                stddvTilt = 0.0; stddvRoll = 0.0;
                if (nsrc > 1) {
                    Tilt = getMedianAngle(nsrc, tilt, 10.0);
                    Roll = getMedianAngle(nsrc, roll, 10.0);
                    stddvTilt = stddev(tilt, nsrc, Tilt);
                    stddvRoll = stddev(roll, nsrc, Roll);
                    if (verbose > 1) warn("3C orientation with std deviation: A=%6.2f T=%6.2f (%4.2f) R=%6.2f (%4.2f)",
                            Azim, Tilt, stddvTilt, Roll, stddvRoll);
                }
                calc3COrient(Azim*PI/180.0, Tilt*PI/180.0, Roll*PI/180.0, azim3c, incl3c);
            }
            if (mode==0 || mode == 2) { // apply rotation
                Project3C(nsrc, 0, nt-1, azim3c, incl3c, indata[xaxis], indata[yaxis], indata[zaxis]);
            }

            for (itr = 0; itr < ntr/nc; ++itr) {
                for (i = 0; i < nc; ++i) {
                    memcpy(&outtr, &hdrs[i][itr], HDRBYTES);
                    memcpy(outtr.data, indata[i][itr], FSIZE * nt);
                    if (mode > 0) {
                        outtr.year = NINT(100.0*azims2r[itr]);
                        outtr.day  = NINT(100.0*incident[itr]);
                        outtr.hour = NINT(100.0*azim[itr]);
                        outtr.minute = NINT(100.0*tilt[itr]);
                        outtr.sec  = NINT(100.0*roll[itr]);
                        outtr.grnors = NINT(100.0*Azim);
                        outtr.grnofr = NINT(100.0*Tilt);
                        outtr.grnlof = NINT(100.0*Roll);
                        if(stddvTilt > 0.0) outtr.gaps  = NINT(100.0*stddvTilt);
                        if(stddvRoll > 0.0) outtr.otrav = NINT(100.0*stddvRoll);
                        outtr.fz = azim3c[2];
                        outtr.dz = incl3c[2];
                        outtr.fx = azim3c[1];
                        outtr.dx = incl3c[1];
                        outtr.fy = azim3c[0];
                        outtr.dy = incl3c[0];
                    }
                    puttr(&outtr);
                }
            }
            val = valnew;
            // reset cache
            memset(*hdrs, 0, nc * nxmax * HDRBYTES);
            memset( **indata, 0, nc * nxmax * nt * FSIZE);
            memset(azim, 0, nxmax * FSIZE);
            memset(tilt, 0, nxmax * FSIZE);
            memset(roll, 0, nxmax * FSIZE);
            memset(azims2r, 0, nxmax * FSIZE);
            memset(incident, 0, nxmax * FSIZE);
            ntr = 0;
            continue;
        }
        nsegy = gettr(&tr);
    } while (!eof);

    if (verbose) warn(" Totally %d traces for each of %d compomnents are processed", ntr/nc, nc);
    
    return(CWP_Exit());
}

void calcOrientations(int nsrc, int itftb, float* azims2r, float* incident, const float azim, float* tilt, float* roll,
                        float** iline, float** xline, float** z)
{
    int itr;

    for (itr=0; itr<nsrc; ++itr) {
        if (!azims2r[itr] && !incident[itr] && !azim) continue;  // skip 
        // minus before xline because y should point to south
        calc3C(azims2r[itr], incident[itr], azim, &tilt[itr], &roll[itr], iline[itr][itftb], -xline[itr][itftb], z[itr][itftb]);
    }

    return;
}

void calc3C(const float azims2r, const float incident, const float azimx, float* tilt, float* roll, const float x, const float y, const float z)
{
    // implemented according to Olofsson et al. Determining 3C geophone orientation from a single shot
    // SEG 2007 extended abstract

    //const float PI = 3.1416;
    
    float epsilon, kappa, theta, phi;

    float incid =  incident*M_PI/180;
    float sin_i =  sinf(incid);
    float cos_i =  cosf(incid);
    float gamma =  azimx*M_PI/180;
    float sin_g =  sinf(gamma);
    float cos_g =  cosf(gamma);
    // determine tilt theta
    float za = sqrtf(x*x + y*y);
          za *= (incident==0.0)? 100.0 : 1.0/tanf(incid);
    float A = sqrtf(x*x + y*y + za*za);
    float a3 = x/A;
    float a4 = y/A;
    float a5 = za/A;
    float bi = sin_i*cosf(azims2r*M_PI/180);
    float bc = sin_i*sinf(azims2r*M_PI/180);
    float bv = cos_i;
    float bir =  bi*cos_g + bc*sin_g;
    float bcr = -bi*sin_g + bc*cos_g;
    float bvr = bv;
    float fsb = sqrtf(bir*bir + bvr*bvr);
    if ( fsb > ABS(a3) ) {   // it can happen fsb <= abs(a3)
        epsilon = acosf(a3/fsb);
    } else if (a3 >= 0.0 ) {
        epsilon = 0.0;
    } else { // a3 < 0 )
        epsilon = M_PI;
    }
    kappa = atan2f(bir, bvr);
    theta = kappa - 0.5*M_PI + epsilon;  // for OBC

    // determine roll phi
    float bvtr = bir*sinf(theta) + bvr*cosf(theta);
    phi = atan2f(bvtr*a4 - bcr*a5, bvtr*a5 + bcr*a4);
    // note: phi, the roll angle is defined here conventionally,
    // anti-clockwise from a4 to a5 (crossline to Z, reversed as defined
    // in paper, in which the formula is wrong

    *tilt = theta*180.0/M_PI;
    *roll = phi*180.0/M_PI;

    return;
}

void calc3COrient(const float gamma, const float theta, const float phi, float* azim3c, float* incl3c)
{
    float sinr = sinf(gamma);
    float cosr = cosf(gamma);
    float sint = sinf(theta);
    float cost = cosf(theta);
    float sinp = sinf(phi);
    float cosp = cosf(phi);

    azim3c[1] = gamma*180.0/PI;  // inline == cable, Y in internal coord. system           // x comp
    incl3c[1] = theta*180.0/PI;    // inline inclination, equal tilt of cable
    azim3c[0] = atan2f(cosr*cosp + sinr*sint*sinp, -sinr*cosp + cosr*sint*sinp)*180.0/PI;  // y comp
    incl3c[0] = -asinf(cost*sinp)*180.0/PI;
    azim3c[2] = atan2f(-cosr*sinp + sinr*sint*cosp, sinr*sinp + cosr*sint*cosp)*180.0/PI;  // z comp
    incl3c[2] = -asinf(cost*cosp)*180.0/PI;
    return;
}

float stddev(float* a, int n, float avg)
{
    int i;
    float asum = 0.0;
    for (i=0; i<n; ++i) asum += (a[i] - avg)*(a[i] - avg);
    return (n>1)? sqrt(asum/n) : 0.0;
}

float getMedianAngle(int ntr, float* ax, float alimit)
{
    int i, itr, na = 0, imaxsector = 0, maxcount = 0 ;
    int nsector = 360/alimit;
    int* count = ealloc1int(nsector);
    memset(count, 0, nsector*sizeof(int));
    for (itr=0; itr<ntr; ++itr) {
        if (ax[itr] == 0.0) continue;  // exclude hard zero, probably not determined value
        i = (int)((ax[itr] + 180.0)/alimit);
        if (i < 0 || i > nsector - 1) continue;
        //if (i < 0) i += nsector;
        //if (i > nsector -1) i -= nsector;
        count[i]++;
    }
    for (i = 0; i < nsector; ++i) {
        if (count[i] > maxcount) {
            imaxsector = i;
            maxcount = count[i];
        }
    }
    float amin = (imaxsector - 1) * alimit - 180.0;
    float amax = (imaxsector + 2) * alimit - 180.0;
    for (itr=0; itr<ntr; ++itr) {
        if (ax[itr] == 0.0) continue;  // exclude hard zero, probably not determined value
        if (imaxsector == nsector - 1 && ax[itr] < -180.0 + alimit) ax[itr] += 360.0;  // -180 ~ -180 + 6
        if (imaxsector == 0 && ax[itr] >  180.0 - alimit) ax[itr] -= 360.0;            // 180 - 6 ~ 180
        if ( ax[itr] < amax && ax[itr] > amin ) ax[na++] = ax[itr];
    }
    if (na == 0) {
        warn("no non-hardzero present, return 0");
        return 0.0;
    }
    float axm = quick_select(ax, na);
    if (axm >  180.0) axm -= 360.0;
    if (axm < -180.0) axm += 360.0;

    free1int(count);
    return axm;
}


// rotate x y according to angle a
void Rotate(int ntr, int nt, float angle, float** x, float** y)
{
    int itr;  // loop counter

    for (itr=0; itr<ntr; ++itr) { // loop over traces
        Rotate2C(0, nt, 0, angle, x[itr], y[itr], x[itr], y[itr]);
    }
}

void Rotate2C(int itmin, int itmax, int skip, float angle, float* x, float* y, float* x1, float* y1)
{
    int it;  // loop counter
    float xtmp, sina, cosa;

    sina = sin(angle*PI/180.0);
    cosa = cos(angle*PI/180.0);

    for (it=itmin; it<=itmax; ++it) { // loop over samples
        if (skip && (x[it] == 0.0 || y[it] == 0.0)) {
            x1[it - itmin] = 0.0;
            y1[it - itmin] = 0.0;
            continue;
        }
        xtmp = cosa*x[it] + sina*y[it];
        y1[it - itmin] = -sina*x[it] + cosa*y[it];
        x1[it - itmin] = xtmp;
    }
    return;
}

void Calc3C(int ntr, int itmin, int itmax, int itftb, float* azim, float* incl, float* aw, float* daa,
        float** x, float** y, float** z)
{
    int it, itr, skip=0;
    float a1, a2, a3, ax1, ax2, ax3, ay1, ay2, ay3, az1, az2, az3;
    float axx, axy, axz, ayx, ayy, ayz, azx, azy, azz;
    float xrms, yrms, zrms, xrmsmax, yrmsmax, zrmsmax, axftb, ayftb, azftb;

    float amin = -aw[0];
    float amax =  aw[0];
    float da   =  daa[0];
    int nt = itmax - itmin + 1;
    float* x1 = ealloc1float(nt);
    float* y1 = ealloc1float(nt);
    float* z1 = ealloc1float(nt);
    for (itr=0; itr<ntr; ++itr) {
        memset(x1, 0, nt*FSIZE);
        memset(y1, 0, nt*FSIZE);
        memset(z1, 0, nt*FSIZE);
        for (a1=amin; a1<=amax; a1 += da) {
            Rotate2C(0, nt, skip, a1, &y[itr][itmin], &z[itr][itmin], y1, z1);
            for (a2=amin; a2<=amax; a2 += da) {
                Rotate2C(0, nt, skip, a2, z1, &x[itr][itmin], z1, x1);
                for (a3=amin; a3<=amax; a3 += da) {
                    Rotate2C(0, nt, skip, a3, x1, y1, x1, y1);
                    xrms = calcRMS(nt, x1);
                    yrms = calcRMS(nt, y1);
                    zrms = calcRMS(nt, z1);
                    if (xrms > xrmsmax ) {
                        axftb = x1[itftb-itmin];
                        xrmsmax = xrms;
                        ax1 = a1;
                        ax2 = a2;
                        ax3 = a3;
                    }
                    if (yrms > yrmsmax ) {
                        ayftb = y1[itftb-itmin];
                        yrmsmax = yrms;
                        ay1 = a1;
                        ay2 = a2;
                        ay3 = a3;
                    }
                    if (zrms > zrmsmax ) {
                        azftb = z1[itftb-itmin];
                        zrmsmax = zrms;
                        az1 = a1;
                        az2 = a2;
                        az3 = a3;
                    }
                }
            }
        }

        // back calc orientation angle from a1, a2, a3
        axx = 0;
    }
    free1float(x1);
    free1float(y1);
    free1float(z1);
    return;
}

void Project3C(int ntr, int itmin, int itmax, float* azim, float* incl,
        float** x, float** y, float** z)
{
    int it, itr;
    int nt = itmax - itmin + 1;
    float* x1 = ealloc1float(nt);
    float* y1 = ealloc1float(nt);
    float* z1 = ealloc1float(nt);
    for (itr=0; itr<ntr; ++itr) {
        memset(x1, 0, nt*FSIZE);
        memset(y1, 0, nt*FSIZE);
        memset(z1, 0, nt*FSIZE);
        Project1C(itmin, itmax, azim[0], incl[0], x[itr], x1, y1, z1);
        Project1C(itmin, itmax, azim[1], incl[1], y[itr], x1, y1, z1);
        Project1C(itmin, itmax, azim[2], incl[2], z[itr], x1, y1, z1);
        for (it=itmin; it<=itmax; ++it) {
            x[itr][it] = x1[it - itmin];
            y[itr][it] = y1[it - itmin];
            z[itr][it] = z1[it - itmin];
        }
    }
    free1float(x1);
    free1float(y1);
    free1float(z1);
    return;
}

void Project1C(int itmin, int itmax, float azim, float incl, float* x, float* x1, float* y1, float* z1)
{
    int it;  // loop counter
    float xtmp, ytmp, ztmp;

    float sina = sin(azim*PI/180.0);
    float cosa = cos(azim*PI/180.0);
    float sini = sin(incl*PI/180.0);
    float cosi = cos(incl*PI/180.0);

    for (it=itmin; it<=itmax; ++it) { // loop over samples
        if (x[it] == 0.0) continue;
        xtmp = cosa*cosi*x[it];
        ytmp = sina*cosi*x[it];
        ztmp = sini*x[it];
        x1[it - itmin] += xtmp;
        y1[it - itmin] += ytmp;
        z1[it - itmin] += ztmp;
    }
    return;
}

float calcRMS(int nt, float* data)
{
    float sum = 0.0;
    int it, nc = 0;
    for (it = 0; it < nt; ++it ) {
        if (data[it] != 0.0 ) {
            ++nc;
            sum += data[it]*data[it];
        }
    }
    return sqrt(sum/nc);
}

float calcMax(int nt, float* data)
{
    float max = 0;
    int it;
    for (it = 0; it < nt; ++it ) {
        if (data[it] != 0.0 ) {
            if ( ABS(data[it]) > max) max = ABS(data[it]);
        }
    }
    return max;
}

/*
 *  This Quickselect routine is based on the algorithm described in
 *  "Numerical recipes in C", Second Edition,
 *  Cambridge University Press, 1992, Section 8.5, ISBN 0-521-43108-5
 *  This code by Nicolas Devillard - 1998. Public domain.
 */

#define ELEM_SWAP(a,b) { register float t=(a);(a)=(b);(b)=t; }

float quick_select(float *arr, int n)
{
    int low, high ;
    int median;
    int middle, ll, hh;

    low = 0 ; high = n-1 ; median = (low + high) / 2;
    for (;;) {
        if (high <= low) /* One element only */
            return arr[median] ;

        if (high == low + 1) {  /* Two elements only */
            if (arr[low] > arr[high])
                ELEM_SWAP(arr[low], arr[high]) ;
            return arr[median] ;
        }

		/* Find median of low, middle and high items; swap into position low */
		middle = (low + high) / 2;
		if (arr[middle] > arr[high])    ELEM_SWAP(arr[middle], arr[high]) ;
		if (arr[low] > arr[high])       ELEM_SWAP(arr[low], arr[high]) ;
		if (arr[middle] > arr[low])     ELEM_SWAP(arr[middle], arr[low]) ;

		/* Swap low item (now in position middle) into position (low+1) */
		ELEM_SWAP(arr[middle], arr[low+1]) ;

		/* Nibble from each end towards middle, swapping items when stuck */
		ll = low + 1;
		hh = high;
		for (;;) {
		    do ll++; while (arr[low] > arr[ll]) ;
		    do hh--; while (arr[hh]  > arr[low]) ;

		    if (hh < ll)
		    break;

		    ELEM_SWAP(arr[ll], arr[hh]) ;
		}

		/* Swap middle item (in position low) back into correct position */
		ELEM_SWAP(arr[low], arr[hh]) ;

		/* Re-set active partition */
		if (hh <= median) low = ll;
		if (hh >= median) high = hh - 1;
	}

    return (n%2)? arr[median] : 0.5*(arr[median] + arr[median + 1]);
}

#undef ELEM_SWAP
