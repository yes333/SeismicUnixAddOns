/* Copyright (c) Colorado School of Mines, 2007.*/
/* All rights reserved.                       */

/* SUSHW: $Revision: 1.21 $ ; $Date: 2004/01/28 21:30:40 $		*/

#include <su.h>
#include <segy.h>
#include <header.h>

/*********************** self documentation ******************************/
char *sdoc[] = {
" 									",
" SUSHW - Set one or more Header Words using trace number, mod and	",
"	 integer divide to compute the header word values or input	",
"	 the header word values from a file				",
" 									",
" Required Parameters for setting headers from binary infile:		",
" key=key1,key2 ... is the list of header fields as they appear in infile",
" infile= 	binary file of values for field specified by		",
" 		key1,key2,...						",
" 									",
" Required Parameters for setting headers from ascii infile/table:	",
" match=key_1,key_2 ... is the list of matching header fields as they appear in infile",
" key=key1,key2     ... is the list of header fields as they appear in infile",
" infile=           ascii table of values for field specified by	",
"                   key_1  key_2 ...  key1 key2 ...			",
"                   ...               ...				",
" 									",
"                   values must be separated by white space             ",
"                   the number of columns must be the same as           ",
"                   that of keys to be matched and to be set            ",
" 									",
" Required Parameters for setting headers from commandline value array:	",
" match=key_1,key_2 ... is the list of matching header fields           ",
" key=key1,key2     ... is the list of header fields                    ",
" values=           array of values for fields specified by             ",
"                   key_1,key_2,...,key1 key2,...,...,...       	",
" 									",
"                   the number of values must be the multiplum of       ",
"                   that of keys to be matched and to be set            ",
" 									",
" Optional parameters ():						",
" key=cdp,...			header key word(s) to set 		",
" a=0,...			value(s) on first trace			",
" b=0,...			increment(s) within group		",
" c=0,...			group increment(s)	 		",
" d=0,...			trace number shift(s)			",
" j=ULONG_MAX,ULONG_MAX,...	number of elements in group		",
" scale=1.0,...                 scaling factor(s) for key word(s) to set",
" 									",
" match=key_1,...	header key word(s) to match, no default         ",
" maxlines=512          max. number of lines in ascii infile (if match=key(s) set)",
" infile=               ascii table of values for field specified by	",
"                       key_1  key_2 ...  key1 key2 ...	"
        "                       or binary file containing values set to header words",
" 									",
" values=               array containing match keys and header words to be set",
" interp=0		=1 linearly interpolate and constantly extrapolate",
" 			   value(s) according to matching keyword	",
" sort=1,,		sort orders for match keys, used only if interp=1",
" 			e.g. =1,-1,1 asc for 1st & 3rd, desc for 2nd key",
" 									",
" verbose=0		=n print out info to stderr for every n-th trace matched",
" 									",
" There are 4 possibilities to set head words:				",
" 									",
" ... compute header fields						",
"   sushw <stdin >stdout key=cdp,.. a=0,..  b=0,.. c=0,.. d=0,.. j=..,..",
" 									",
" ... or set headers from a binary file				",
"   sushw <stdin > stdout  key=key1,..    infile=binary_file		",
" 									",
" ... or set headers from a ascii file				        ",
"   sushw match=key_1,..  scale=1.0,.. maxlines=1024 \\                 ",
"         key=key1,..    infile=ascii_file	<stdin > stdout         ",
" 									",
" ... or set headers from an array of values as an command line argument",
"   sushw match=key_1,.. key=key1,.. interp=1 <stdin >stdout \\         ",
"     values=k1,k2,..v1,v2,..,...                                       ",
" 									",
" Notes:								",
" Fields that are getparred must have the same number of entries as key	",
" words being set. Any field that is not getparred is set to the default",
" value(s) above. Explicitly setting j=0 will set j to ULONG_MAX.	",
" 									",
" The value of each header word key is computed using the formula:	",
" 	i = itr + d							",
" 	val(key) = ( a + b * (i % j) + c * (i / j) ) * scale		",
" where itr is the trace number (first trace has itr=0, NOT 1)		",
" 									",
" Examples:								",
" 1. set every dt field to 4ms						",
" 	sushw <indata key=dt a=4000 |...				",
" 2. set the sx field of the first 32 traces to 6400, the second 32 traces",
"    to 6300, decrementing by -100 for each 32 trace groups		",
"   ...| sushw key=sx a=6400 c=-100 j=32 |...				",
" 3. set the offset fields of each group of 32 traces to 200,400,...,6400",
"   ...| sushw key=offset a=200 b=200 j=32 |...				",
" 4. perform operations 1., 2., and 3. in one call			",
"  ..| sushw key=dt,sx,offset a=4000,6400,200 b=0,0,200 c=0,-100,0 j=0,32,32 |",
" 									",
" In this example, we set every dt field to 4ms.  Then we set the first	",
" 32 shotpoint fields to 6400, the second 32 shotpoint fields to 6300 and",
" so forth.  Next we set each group of 32 offset fields to 200, 400, ...,",
" 6400.									",
" 									",
" Example of a typical processing sequence using suchw:			",
"  sushw <indata key=dt a=4000 |					",
"  sushw key=sx a=6400 c=-100 j=32 |					",
"  sushw key=offset a=200 b=200 j=32 |			     		",
"  suchw key1=gx key2=offset key3=sx b=1 c=1 |		     		",
"  suchw key1=cdp key2=gx key3=sx b=1 c=1 d=2 >outdata	     		",
" 									",
" Again, it is possible to eliminate the multiple calls to both sushw and",
" sushw, as in Example 4.						",
" 									",
" Reading header values from a binary file:				",
" If the parameter infile=binary_file is set, then the values that are to",
" be set for the fields specified by key=key1,key2,... are read from that",
" file. The values are read sequentially from the file and assigned trace",
" by trace to the input SU data. The infile consists of C (unformated)	",
" binary floats in the form of an array of size (nkeys)*(ntraces) where	",
" nkeys is the number of floats in the first (fast) dimension and ntraces",
" is the number of traces.						",
" 									",
" Reading header values from a ascii table:				",
" If the parameter infile=ascii_file is set, then the entire table is read",
" in and cached in the memory. When a trace is read the values of trace ",
" headers specified by key=key_1,key_2,... are compared to the cached table.",
" If a match is found, the trace fields specified by key=key1,key2,... are",
" set to the values of the corresponding record. If no match is found, the",
" header values remain unchanged by default setting interp=0. However, if",
" interp=1, header values are linearly interpolated and constantly extrapolated",
" by matching headers. The interp=1 option is meant to load parameters",
" like muting table, scaling factors etc. Interpolation/extraplolation ",
" works only for up to three keys, e.g. inline, crossline, and offset.",
" The value is first interpolated between two adjacent offset, then crossline,",
" and last inline. The parameter to be interpolated should sampled densely",
" enough along every inline that are presented in the table.            ",
" 									",
" Comment: 								",
" Users wishing to edit one or more header fields (as in geometry setting)",
" may do this via the following sequence:				",
"     sugethw < sudata output=geom  key=key1,key2 ... > hdrfile 	",
" Now edit the ASCII file hdrfile with any editor, setting the fields	",
" appropriately. Convert hdrfile to a binary format via:		",
"     a2b < hdrfile n1=nfields > binary_file				",
" Then set the header fields via:					",
"     sushw < sudata infile=binary_file key1 key2 ... > sudata.edited	",
" Alternatively header fields can be output with key values, edited and ",
" read in again:                                                        ",
"     sugethw < sudata output=geom  key=key_1,...,key1,key2 ... > hdrfile",
"     sushw match=key_1,... key=key1,key2,... infile=hdrfile.edited     ",
"           < sudata > sudata.edited					",
" 									",
" 									",
" Caveat: 								",
" If the (number of traces)*(number of key words) exceeds the number of	",
" values in the infile then the user may still set a single header field",
" on the remaining traces via the parameters key=keyword a,b,c,d,j.	",
"  									",
" Example:								",
"    sushw < sudata key=key1,key2 ... infile=binary_file [Optional Parameters]",
NULL};

/* Credits:
 *	SEP: Einar Kajartansson
 *	CWP: Jack K. Cohen
 *      CWP: John Stockwell, added multiple fields and infile= options
 *      RWS: Sanyu Ye, added ascii file/array of multiple fields according to matching keys
 *
 * Caveat:
 *	All constants are cast to doubles.
 */
/**************** end self doc ****************************************/


segy tr;

int verbose = 0;

/* Prototypes */
double mod(double x, double y);
void setval(cwp_String type, Value *valp, double a, double b,
        double c, double i, double j, double scale);

int FindInterval(int ikey, double dv, double *dprev, double **keys, int *order,
        int nRows, int *nbegp,  int* n1p, int* n2p, double* d1p, double* d2p);

void interp1(int ikey,  int* sort, int n1, int n2, double d, double **keys, double **var, int nv, double* v);

void interp2(int sort, double d, double d1, double d2, double *v1, double *v2, int nv, double* v);

int interp(int nkeys, double *dv, double **keys, int *sort, int nRows, double **var, int nv, double* v);

int main(int argc, char **argv) {
    cwp_String mkey[SU_NKEYS];  /* array of keywords to match		*/
    cwp_String mtype[SU_NKEYS]; /* array of types name		*/
    int mindex[SU_NKEYS];	/* index array of keywords to match	*/
    Value valm[SU_NKEYS];	/* value array of matching keywords from trace */

    int mnkeys;		/* number of header fields set for matching keys	*/
    int mcount=0;		/* number of traces matched 	*/

    double *values = NULL;  /* pointer containing value array */
    double **mkeys = NULL;  /* pointer containing values of matching keys */
    double **vkeys = NULL;  /* pointer containing values of keys to be set */

    int maxRows = 0;        /* max. number of lines of ascii infile */
    int nRow = 0;           /* actual number of lines of ascii infile read in*/

    cwp_String key[SU_NKEYS];  /* array of keywords			*/
    cwp_String type[SU_NKEYS]; /* array of keywords			*/
    int index[SU_NKEYS];	/* name of type	of getparred key	*/
    double dintp[SU_NKEYS]; /* key values obtained through interpolation */

    int ikey;		/* key counter 				*/
    int nkeys;		/* number of header fields set		*/
    int count=0;		/* number of header fields from file	*/
    int nvalues=0;		/* number of elements in value array	*/

    double i;		/* parameters for computing fields	*/
    int itr = 0;		/* trace counter 			*/
    Value val;		/* value of key field to set		*/

    char *infile="";	/* name of input file of header values	*/
    FILE *infp=NULL;	/* pointer to input file		*/
    cwp_Bool from_file=cwp_false; /* is the data from infile?	*/

    float *afile=NULL;	/* array of "a" values from file	*/
    double *a=NULL;		/* array of "a" values			*/
    double *b=NULL;		/* array of "b" values			*/
    double *c=NULL;		/* array of "c" values			*/
    double *d=NULL;		/* array of "d" values			*/
    double *j=NULL;		/* array of "j" values			*/
    double *scale=NULL;	/* scaling factor for keys to be set	*/
    int *sort=NULL;	        /* sorting order for keys to be matched	*/
    int n;			/* number of a,b,c,d,j values		*/

    int interpolate = 0;    /* if set !=0, interpolate/extrapolate */

    /* Initialize */
    initargs(argc, argv);
    requestdoc(1);

    /* Get "key" values */
    if ((nkeys=countparval("key"))!=0) {
        getparstringarray("key", key);

    } else {
        nkeys = 1;
        key[0]="cdp";
    }

    /* get types and indexes corresponding to the keys */
    for (ikey=0; ikey<nkeys; ++ikey) {
        type[ikey]=hdtype(key[ikey]);
        index[ikey]=getindex(key[ikey]);
    }

    /* Get matching "key" values */
    if ((mnkeys=countparval("match"))!=0) {
        getparstringarray("match", mkey);

        /* get types and indexes corresponding to the matching keys */
        for (ikey=0; ikey<mnkeys; ++ikey) {
            mtype[ikey]=hdtype(mkey[ikey]);
            mindex[ikey]=getindex(mkey[ikey]);
        }

        if (!getparint("maxlines", &maxRows))	maxRows = 512;
        if (!getparint("verbose", &verbose))	verbose = 0;
        if (!getparint("interp", &interpolate))     interpolate = 0;
    }

    /* get name of infile */
    getparstring("infile", &infile);

    /* if infile is specified get specified keys from file */
    if (*infile!='\0') {

        /* open infile */
        if((infp=efopen(infile, "r"))==NULL)
            err("cannot open infile=%s\n", infile);

        /* set from_file flag */
        from_file=cwp_true;
    }

    // get value array
    if (mnkeys > 0 && !from_file) {
        nvalues = countparval("values");
        if ( nvalues % (mnkeys + nkeys) != 0) {
            err("Number of values must be multiplum of that of keys to be matched and set!");
        }
        values=ealloc1double(nvalues);
        getpardouble("values", values);
        from_file=cwp_true;
    }

    /* get sorting order of match keys if interpolation applies */
    if ( interpolate ) {
        if ((n=countparval("sort"))!=0) {
            if (n>mnkeys) {
                err("number of sort's cannot be large than key's!");
            } else {
                sort=ealloc1int(mnkeys);
                getparint("sort", sort);
                if (n<mnkeys) {
                    for (ikey=n; ikey<mnkeys; ++ikey) {
                        sort[ikey]=sort[n-1];
                    }
                }
            }
        } else { /* set default */
            sort=ealloc1int(mnkeys);
            for (ikey=0; ikey<mnkeys; ++ikey)
                sort[ikey]=1;
        }
    }

    /* get scaling factors */
    if ((n=countparval("scale"))!=0) {
        if (n>nkeys) {
            err("number of scale's cannot be large than key's!");
        } else {
            scale=ealloc1double(nkeys);
            getpardouble("scale", scale);
            if (n<nkeys) {
                for (ikey=n; ikey<nkeys; ++ikey) {
                    scale[ikey]=scale[n-1];
                }
            }
        }
    } else { /* set default */
        scale=ealloc1double(nkeys);
        for (ikey=0; ikey<nkeys; ++ikey)
            scale[ikey]=1.;
    }

    /* If not from file or value array, getpar a,b,c,d,j */
    if (!from_file && nvalues == 0) {
        /* get "a" values */
        if ((n=countparval("a"))!=0) {
            if (n!=nkeys)
                err("number of a values not equal to number of keys");

            a=ealloc1double(n);
            getpardouble("a", a);
        } else {
            a=ealloc1double(nkeys);
            for (ikey=0; ikey<nkeys; ++ikey) a[ikey]=0.;
        }

        /* get "b" values */
        if ((n=countparval("b"))!=0) {
            if (n!=nkeys)
                err("number of b values not equal to number of keys");

            b=ealloc1double(n);
            getpardouble("b", b);
        } else {
            b=ealloc1double(nkeys);
            for (ikey=0; ikey<nkeys; ++ikey) b[ikey]=0.;
        }

        /* get "c" values */
        if ((n=countparval("c"))!=0) {
            if (n!=nkeys)
                err("number of c values not equal to number of keys");

            c=ealloc1double(n);
            getpardouble("c", c);
        } else {
            c=ealloc1double(nkeys);
            for (ikey=0; ikey<nkeys; ++ikey) c[ikey]=0.;
        }

        /* get "d" values */
        if ((n=countparval("d"))!=0) {
            if (n!=nkeys)
                err("number of d values not equal to number of keys");

            d=ealloc1double(n);
            getpardouble("d", d);
        } else {
            d=ealloc1double(nkeys);
            for (ikey=0; ikey<nkeys; ++ikey) d[ikey]=0.;
        }

        /* get "j" values */
        if ((n=countparval("j"))!=0) {
            if (n!=nkeys)
                err("number of j values not equal to number of keys");

            j=ealloc1double(n);
            getpardouble("j", j);

            /* make sure that j!=0 */
            for (ikey=0; ikey<nkeys; ++ikey)
                if(j[ikey]==0) j[ikey]=ULONG_MAX;
        } else {
            j=ealloc1double(nkeys);
            for (ikey=0; ikey<nkeys; ++ikey) j[ikey]=ULONG_MAX;
        }
    } else if (mnkeys == 0) { /* if reading from a file */
        /* allocate space for afile */
        afile=ealloc1float(nkeys);
    } else {  /* if reading from a acsii file/table or value array*/
        if ( nvalues == 0 ) { // read from ascii file
            int bEnd = 0;

            mkeys = ealloc2double(mnkeys, maxRows);
            vkeys = ealloc2double(nkeys, maxRows);

            if (verbose) warn("m=%d n=%d file=%s" , mnkeys, nkeys, infile);
            /* reading all data from ascii infile */
            /*  fscanf returns: 0   : characters there, but no conversion (error)
             *		  EOF : eof before conversion
             *		  else: number of conversions
             */
            for (nRow=0; nRow < maxRows; ++nRow) {
                for (ikey = 0; ikey < mnkeys; ++ikey ) {
                    int ret = fscanf(infp, "%lf", &mkeys[nRow][ikey]);
                    if(ret == EOF) {
                        bEnd = 1; break;  /* else everything is okay: get out of the loop */
                    }
                    if(ret == 0) {
                        bEnd = 1; break;  /* else everything is okay: get out of the loop */
                    }
                }
                for (ikey = 0; ikey < nkeys && !bEnd; ++ikey ) {
                    int ret = fscanf(infp, "%lf", &vkeys[nRow][ikey] );
                    if(ret == EOF) {
                        bEnd = 1; break;  /* else everything is okay: get out of the loop */
                    }
                    if(ret == 0) {
                        bEnd = 1; break;  /* else everything is okay: get out of the loop */
                    }
                }

                if (bEnd) break;
            }
        } else { // read from value array
            maxRows = nvalues / (mnkeys + nkeys);
            mkeys = ealloc2double(mnkeys, maxRows);
            vkeys = ealloc2double(nkeys, maxRows);
            for (nRow = 0; nRow < maxRows; ++nRow) {
                for (ikey = 0; ikey < mnkeys; ++ikey ) {
                    mkeys[nRow][ikey] = (double) values[nRow*(mnkeys + nkeys) + ikey];
                }
                for (ikey = 0; ikey < nkeys; ++ikey ) {
                    vkeys[nRow][ikey] = (double) values[nRow*(mnkeys + nkeys) + mnkeys + ikey];
                }
            }
            nRow = maxRows;
        }

        if (verbose) warn("%d lines read", nRow);
        if (verbose >= 10) {
            for (n=0; n < nRow; ++n) {
                fprintf(stderr, "%4d -> ", n);
                for (ikey = 0; ikey < mnkeys; ++ikey ) {
                    fprintf(stderr, " %6d ", (int)mkeys[n][ikey]);
                }
                for (ikey = 0; ikey < nkeys; ++ikey ) {
                    fprintf(stderr, " %.2f ", vkeys[n][ikey]);
                }
                fprintf(stderr, " END\n");
            }
        }
    }

    /* loop over traces */
    while (gettr(&tr)) {

        if (from_file && mnkeys > 0) {  /* match keys and set value from file to trace by trace */

            cwp_Bool isMatch = cwp_false;

            /* loop over matching key fields and get values */
            for (ikey=0; ikey<mnkeys; ++ikey) {
                /* get header values */
                gethval(&tr, mindex[ikey], &valm[ikey]);
            }

            if (!interpolate) { /* no interpolation, exact match of key values required */
                for (n = 0; n < nRow && !isMatch; ++n) {
                    for (ikey=0, isMatch = cwp_true; ikey<mnkeys; ++ikey) {
                        setval(mtype[ikey], &val, mkeys[n][ikey], 0, 0, 0, ULONG_MAX, 1.0);
                        isMatch = isMatch && !valcmp(mtype[ikey], valm[ikey], val);
                    }
                }

                if (isMatch) {
                    /*warn("found match for trace %d key[%d][0]=%d" , itr,  n-1,(int) mkeys[n-1][0]);*/
                    for (ikey=0; ikey<nkeys; ++ikey) {
                        setval(type[ikey], &val, vkeys[n-1][ikey], 0, 0, 0, ULONG_MAX, scale[ikey]);
                        puthval(&tr, index[ikey], &val);
                    }
                    ++mcount;
                }
            } else { /* interpolation/extrapolation */
                double d[3];

                if ( mnkeys > 3 ) err("Interpolation over >3 keys is not implemented");
                for (ikey=0; ikey<mnkeys; ++ikey){
                    d[ikey] = vtod(mtype[ikey], valm[ikey]);
                }

                interp(mnkeys, d, mkeys, sort, nRow, vkeys, nkeys, dintp);
                for (ikey=0; ikey<mnkeys && verbose>30; ++ikey){
                    fprintf(stderr, "%s=%d ", mkey[ikey], (int) d[ikey]);
                }
                for (ikey=0; ikey<nkeys && verbose>30; ++ikey){
                    fprintf(stderr, "dintp[%d]=%f ", ikey, dintp[ikey]);
                }
                if (verbose>30) fprintf(stderr, "\n");
                for (ikey=0; ikey<nkeys; ++ikey) {
                    setval(type[ikey], &val, dintp[ikey], 0, 0, 0, ULONG_MAX, scale[ikey]);
                    puthval(&tr, index[ikey], &val);
                }
                ++mcount;
            }
        } else if (from_file) {/* use the "a" value from file to trace by trace */
            if (efread(afile, FSIZE, nkeys, infp)!=0) {
                for (ikey=0; ikey<nkeys; ++ikey) {
                    double a_in;
                    a_in=(double) afile[ikey];
                    setval(type[ikey], &val, a_in,
                            0, 0, 0, ULONG_MAX, scale[ikey]);
                    puthval(&tr, index[ikey], &val);
                    ++count;
                }
            }
        } else { /* use getparred values of a,b,c,d,j */
            for (ikey=0; ikey<nkeys; ++ikey) {
                i = (double) itr + d[ikey];

                setval(type[ikey], &val, a[ikey], b[ikey],
                        c[ikey], i, j[ikey], scale[ikey]);
                puthval(&tr, index[ikey], &val);
            }
        }

        ++itr;
        puttr(&tr);
    }

    if (from_file) {
        if (infp) efclose(infp);
        if (mnkeys>0) {
            warn("  %d traces of total %d set with new header values", mcount, itr);
        } else if (count < (int)(itr*nkeys) ) {
            warn("itr=%d > count=%d", (int) itr*count, count);
            warn("n traces=%d > data count =%d", (itr*nkeys), count);
        }
    }

    /* free allocated memory */
    if (a) free1double(a);
    if (b) free1double(b);
    if (c) free1double(c);
    if (d) free1double(d);
    if (j) free1double(j);
    if (sort) free1int(sort);
    if (scale) free1double(scale);
    if (afile) free1float(afile);
    if (mkeys) free2double(mkeys);
    if (vkeys) free2double(vkeys);
    if (values) free1double(values);

    return(CWP_Exit());
}


void setval( cwp_String type, Value *valp, double a, double b,
        double c, double i, double j, double scale) {
    switch (*type) {
        case 's':
            err("can't set char header word");
            break;
        case 'h':
            valp->h = scale * (a + b * mod(i, j) + c * ((int) (i/j)));
            break;
        case 'u':
            valp->u = scale * (a + b * mod(i, j) + c * ((int) (i/j)));
            break;
        case 'l':
            valp->l = (long) (scale * ((a + b * mod(i, j) + c * ((int) (i/j)))));
            break;
        case 'v':
            valp->v = (unsigned long) (scale * ((a + b * mod(i, j) + c * ((int) (i/j)))));
            break;
        case 'i':
            valp->i = scale * (a + b * mod(i, j) + c * ((int) (i/j)));
            break;
        case 'p':
            valp->p = scale * (a + b * mod(i, j) + c * ((int) (i/j)));
            break;
        case 'f':
            valp->f = scale * (a + b * mod(i, j) + c * ((int) (i/j)));
            break;
        case 'd':
            valp->d = scale * (a + b * mod(i, j) + c * ((int) (i/j)));
        default:
            err("unknown type %s", type);
            break;
    }
    return;
}


double mod(double x, double y)	/* As defined in Knuth, vol. 1	*/ {
    return y == 0.0 ? x : x - y * floor(x/y);
}


/* Copyright (c) READ Well Service, 2007.*/
/* All rights reserved.                       */

/*********************** self documentation **********************/
/******************************************************************************
* Functions with prototypes for functions used internally to interpolate
* header values based on up to 3 keywrods
* Written by Sanyu Ye, sanyu.ye@readgroup.com
******************************************************************************
*
******************************************************************************/
/**************** end self doc ********************************/

int FindInterval(
    int ikey,        /* key level/index to search (which match key) */
    double dv,       /* value to be searched */
    double *dprev,   /* values of previous keys that must be matched during the search */
    double **keys,  /* array containing the input table of match keys */
    int *sort,      /* sorting order of the input match keys, >0 ascending, <0 descending */
    int nRows,       /* Total number of the rows/lines of input match keys */
    int *nbegp,      /* input: starting search line; output: new starting line for next search */
    int* n1p, int* n2p, /* interval of line number between which the searched value located */
    double* d1p, double* d2p /* interval of key values between which the search value located */
    /* return value =-2 beyond first row; =+-1 between two rows; =0 exact match; =2 beyond last row */
    ) 
{
    int startIntervalFound = 0, match = sort[ikey];
    double prevKeyValue = (sort[ikey] > 0 )? (double) INT_MIN : (double) INT_MAX;
    for (int n = *nbegp; n < nRows; ++n) {  // loop over rows of match keys
        int isMatchPrevKeys = 1;
        // in case of search for 2nd or third key, find first match in previous keys
        for (int i=0; i<ikey && isMatchPrevKeys; ++i) {
            isMatchPrevKeys = isMatchPrevKeys && dprev[i] == keys[n][i];
        }

        if (!isMatchPrevKeys ) continue; /* skip to first line that previous key values matched*/

        if ( keys[n][ikey] == prevKeyValue ) continue;  // skip line with same key value
        else { // key value change
            prevKeyValue = keys[n][ikey];

            if ( dv == keys[n][ikey] ) { // exact match found, break
                *nbegp = n;  /* new start point for next level search */
                *d1p = *d2p = keys[n][ikey];
                *n1p = *n2p = n;
                match = 0;
                break;
            } else if ( (sort[ikey] > 0 && dv > keys[n][ikey]) 
                     || (sort[ikey] < 0 && dv < keys[n][ikey]) ) { // first value of interval found
                *nbegp = n;  /* new start point for next level search */
                *d1p = *d2p = keys[n][ikey];
                *n1p = *n2p = n;
                startIntervalFound = 1;
            } else if ( (sort[ikey] > 0 && dv < keys[n][ikey]) /*check if second value of interval found */ 
                     || (sort[ikey] < 0 && dv > keys[n][ikey]) ) {
                *d2p = keys[n][ikey];
                *n2p = n;
                
                if (!startIntervalFound) { // even the start is not found
                    *nbegp = n;  /* new start point for next level search */
                    *d1p = *d2p;
                    *n1p = *n2p;
                    match = 2;
                }
                break;
            }
        } 
    }
    return match;
}

void interp1(
    int     ikey,   /* index of match key */
    int*   sort,    /* sorting array */
    int     n1,     /* first row */
    int     n2,     /* last row between them the values are interpolated */
    double  d,      /* key value of trace to which the interpolation is done */
    double  **keys, /* 2-D array of input table values of match keys */
    double  **var, /* 2-D array of input table values */
    int     nv,     /* array size */
    double* v   /* output values interpolated */
    ) 
{
    int i;
    for ( i=0; i<nv; ++i) {
        if ( (sort[ikey] > 0 && d <= keys[n1][ikey]) || (sort[ikey] < 0 && d >= keys[n1][ikey]) )  v[i] = var[n1][i];
        else if ( (sort[ikey] > 0 && d >= keys[n2][ikey]) || (sort[ikey] < 0 && d <= keys[n2][ikey]) ) v[i] = var[n2][i];
        else if( n1 == n2 || keys[n2][ikey] == keys[n1][ikey] ) v[i] = (var[n1][i] + var[n2][i])/2;
        else v[i] = var[n1][i] + (var[n2][i] - var[n1][i])*(d - keys[n1][ikey])/(keys[n2][ikey] - keys[n1][ikey]);
    }
    return;
}

void interp2(
    int         sort,  /* sort direction */
    double  d,      /* key value of trace to which the interpolation is done */
    double  d1,      /* first key value  */
    double  d2,      /* second key value  */
    double* v1,  /* first 1-D array to interpolation between */
    double* v2,  /* second 1-D array to interpolation between */
    int     nv,    /* array size */
    double* v    /* output values interpolated */
    ) 
{
    int i;
    for ( i=0; i<nv; ++i) {
        if ( (sort > 0 && d <= d1) || (sort < 0 && d >= d1) ) v[i] = v1[i];
        else if ( (sort > 0 && d >= d2) || (sort < 0 && d <= d2) ) v[i] = v2[i];
        else if( d1 == d2 ) v[i] = (v1[i] + v2[i])/2;
        else v[i] = v1[i] + (v2[i] - v1[i])*(d - d1)/(d2 - d1);
    }
    return;
}

int interp(
    int nkeys,      /* Number of the match keys */
    double *d,      /* 1D array of key values to be searched */
    double **keys,  /* 2D array containing the input table of match keys */
    int *sort,      /* sorting order of the input match keys, >0 ascending, <0 descending */
    int nRows,      /* Total number of the rows/lines of input match keys */
    double **var,   /* 2D array containing the input table of values */
    int nv,         /* Total number of the keys to be set */
    double* v       /* interval of key values between which the search value located */
    /* return value =-2 beyond first row; =+-1 between two rows; =0 exact match; =2 beyond last row */
    ) 
{
    int n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14;
    int nbeg1=0, nbeg3, nbeg5, nbeg7, nbeg9, nbeg11, nbeg13;
    double d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14;
    double *v3=NULL, *v5=NULL, *v7=NULL, *v9=NULL, *v11=NULL, *v13=NULL;
    double dprev[2] = {0, 0};
    int match;

    if ( nkeys > 3 ) err("interpolation not implemented for more than 1D");

    match = FindInterval(0, d[0], dprev, keys, sort, nRows, &nbeg1, &n1, &n2, &d1, &d2);
    if (verbose > 100) fprintf(stderr, "%d %f %f %f %f %d %d %d %f %f\n", 0, d[0], dprev[0], keys[n1][0], keys[n2][0], nbeg1, n1, n2, d1, d2);
    if ( 1 == nkeys ) { /* just 1-D interpolation */
        interp1(0, sort, n1, n2, d[0], keys, var, nv, v );
        return 1;
    } else { /* one level more */
        dprev[0] = d1; nbeg3 = n1;
        match = FindInterval(1, d[1], dprev, keys, sort, nRows, &nbeg3, &n3, &n4, &d3, &d4);
        if (verbose>100) fprintf(stderr, "%d %f %f %f %f %d %d %d %f %f\n", 1, d[1], dprev[0], keys[n3][1], keys[n4][1], nbeg3, n3, n4, d3, d4);
        if ( d1 != d2 ) {
            dprev[0] = d2; nbeg5 = n2;
            match = FindInterval(1, d[1], dprev, keys, sort, nRows, &nbeg5, &n5, &n6, &d5, &d6);
            if (verbose>100) fprintf(stderr, "%d %f %f %f %f %d %d %d %f %f\n", 1, d[1], dprev[0], keys[n5][1], keys[n6][1], nbeg5, n5, n6, d5, d6);
        } else {
            n5 = n3; n6 = n4; d5 = d3; d6 = d4;
        }
        if ( 2 == nkeys ) { /* 2D */
            v3 = ealloc1double(nv);
            v5 = ealloc1double(nv);
            interp1(1, sort, n3, n4, d[1], keys, var, nv, v3 );
            interp1(1, sort, n5, n6, d[1], keys, var, nv, v5 );
            interp2(sort[0], d[0], d1, d2, v3, v5, nv, v );
            free1double(v3);
            free1double(v5);
            return 2;
        } else { /* 3D, one level more */
            dprev[0] = d1; dprev[1] = d3; nbeg7 = n3;
            match = FindInterval(2, d[2], dprev, keys, sort, nRows, &nbeg7, &n7, &n8, &d7, &d8);
            dprev[0] = d1; dprev[1] = d4; nbeg9 = n4;
            match = FindInterval(2, d[2], dprev, keys, sort, nRows, &nbeg7, &n9, &n10, &d9, &d10);
            dprev[0] = d2; dprev[1] = d5; nbeg11 = n5;
            match = FindInterval(2, d[2], dprev, keys, sort, nRows, &nbeg11, &n11, &n12, &d11, &d12);
            dprev[0] = d2; dprev[1] = d6; nbeg13 = n6;
            match = FindInterval(2, d[2], dprev, keys, sort, nRows, &nbeg13, &n13, &n14, &d13, &d14);
            v3 = ealloc1double(nv);
            v5 = ealloc1double(nv);
            v7 = ealloc1double(nv);
            v9 = ealloc1double(nv);
            v11 = ealloc1double(nv);
            v13 = ealloc1double(nv);
            interp1(2, sort, n7, n8, d[2], keys, var, nv, v7 );
            interp1(2, sort, n9, n10, d[2], keys, var, nv, v9 );
            interp1(2, sort, n11, n12, d[2], keys, var, nv, v11 );
            interp1(2, sort, n13, n14, d[2], keys, var, nv, v13 );
            interp2(sort[1], d[1], d3, d4, v7, v9, nv, v3 );
            interp2(sort[1], d[1], d5, d6, v11, v13, nv, v5 );
            interp2(sort[0], d[0], d1, d2, v3, v5, nv, v );
            free1double(v3);
            free1double(v5);
            free1double(v7);
            free1double(v9);
            free1double(v11);
            free1double(v13);
            return 3;
        }
    }
}
