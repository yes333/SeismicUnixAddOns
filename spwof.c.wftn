/* Copyright (c) Read Well Services, 2011.*/
/* All rights reserved.                       */

/* SUWOF: $Revision: 1.0.0 $ ; $Date: 2011/04/09  $		*/

#include "su.h"
#include "segy.h"
#include "header.h"
#include "segyhdr.h"

/*********************** self documentation ******************************/
char *sdoc[] = {
"                                                                               ",
" SPWOF - Wiener optimum filter for wavelet shaping/deterministic deconvolution ",
"                                                                               ",
" spwpef <stdin >stdout  [optional parameters]                                  ",
"                                                                               ",
" Optional parameters:                                                          ",
" key=cdpt              gather sorting key                                      ",
" output=5              =5 output filtered traces                               ",
"                       =4 output Wiener filters                                ",
"                       =3 output cross correlation                             ",
"                       =2 output weighted autocorrelations                     ",
"                       =1 output autocorrelations                              ",
" input=1               =1 input contain only (downgoing) traces for filter design",
"                          this option is used for QC purpose                   ",
"                       =2 designed filter applied to next trace (upgoing)      ",
"                          requiring down- and upgoing input trace by trace     ",
"                                                                               ",
" nxmax=tr.sfs          max. number of trace in x direction                     ",
" nymax=tr.sfe          max. number of trace in y direction                     ",
"                                                                               ",
" trid=trid             key holding trace id                                    ",
" use=                  trids of traces used to design filter. Default: all     ",
" apply=                trids of traces shaping filter is applied to. Default: all",
"                                                                               ",
" wavelet=              desired output wavelet. If not given, a spike at delay=   ",
"                                                                               ",
" delay=0        [s]    delay time of max. energy of desired output wavelet     ",
" fl=1.0         [s]    filter length                                           ",
" al=0.4         [s]    anticipation length. if >0 noncausal, two-sided filter  ",
"                       total length of wiener filter is extented accordingly   ",
" mincorr=stas          key holding start of autocorrelation window in milisecond",
" maxcorr=stae          key holding end of autocorrelation window               ",
" nw=1,1                trace window in x/y direction for mixing autocorrelation",
" mix=1                 =1 boxcar; =2 Gausian; 3 cosine                         ",
"			  weighting function for averaging autocorrelations	",
" pnoise=0.1     [%]    percentage of relative additive noise level             ",
" verbose=0             >0 output info                                          ",
"                                                                               ",
" Notes:                                                                        ",
"                                                                               ",
" This is an extented version of SUPEF, capable of handling 3D gather and varying",
" parameters for both Wiener filter and autocorrelation window. These parameters",
" should be set/loaded using SUSHW. Input gathers are not required to be regularly",
" sampled, but sorted by shotline and numbered in X and Y position using SUSETGATHER",
" with index stored in keywords nhs and nvs. To improve S/N ratio, autocorrelations",
" of adjacent traces are weighted and summed together. The trace window in X/Y  ",
" is defined by parameter nw=nwx,nwy.                                           ",
" If gathers are not regularly sampled with varying number of traces, nxmax and ",
" nymax must be set big enough to hold the largest one. Only traces with non-zero",
" positive trace id value will be processed and output. If autocorrelation of a ",
" trace becomes zero, in case the correlation window is muted, the trace id is  ",
" negated and only processed if trace/autocorrlation mixing is enabled.         ",
"                                                                               ",
" Typical flow example looks like:                                              ",
"                                                                               ",
" spdbread select=\"cdpt+|ep+|sx+...\" |\\ ",
" ......  |\\ ",
" susetgather key=cdpt xkey=sx |\\ ",
" sushw match=offset key=laga,lagb,stas,stae infile=windows.tbl |\\ ",
" spwpef key=cdpt nw=11,5 |\\  ",
" su...  ",
"                                                                               ",
" assuming here cdpt hold receiver no, ep shotline number                       ",
"                                                                               ",
" More about parameters min and maxlag see selfdoc of SUPEF          		",
"                                                                               ",
" Version 0.9.0 last modified March. 2011 by Sanyu Ye                             ",
"                                                                               ",
 NULL};

/* Credits:
 *	CWP: Shuki Ronen, Jack K. Cohen, Ken Larner
 *      RWS: Sanyu Ye, Feb. 2011
 *
 *      Technical Reference:
 *	A. Ziolkowski, "Deconvolution", for value of maxlag default:
 *		page 91: imaxlag < nt/10.  I took nt/20.
 *
 * Notes:
 *	The prediction error filter is 1,0,0...,0,-wiener[0], ...,
 *	so no point in explicitly forming it.
 *
 *	If imaxlag < 2*iminlag - 1, then we don't need to compute the
 *	autocorrelation for lags:
 *		imaxlag-iminlag+1, ..., iminlag-1
 *	It doesn't seem worth the duplicated code to implement this.
 *
 */
/**************** end self doc *******************************************/


/* External definitions */
#define PNOISE	0.1			/* default pnoise value		*/
#define VAL0    1.0			/* default weighting value	*/

// forward declare prototype
int CalcMix(int mix, int nwx, int nwy, float** weight);
int CalcAvgAC(int nxmax, int nymax, int** trid, float*** acorr,
        int nwx, int nwy, float** weight, int ix, int iy, int ncorr, float* AvgAC);

void vpwien_(void* WAVLT,  int* LWAVLT, float* DOUT, int* LDOUT, float* WSTAB,  float* WGAIN , int* LFIL, int* inpanti,
        float* FILT, int* IOPT, int* IER, float* filmax, float* XC, float* AC, float* APWORK, float* ERFILT, float* TEMP, int* nmax);

int main(int argc, char **argv)
{
    cwp_String key, key3, key4, key5;     /* header key word from segy.h */
    cwp_String type, type3, type4, type5;    /* type of key	*/
    int index, index3, index4, index5;     /* index of key	*/
    Value val, valnew, vala;  /* value of key				*/
    int nsegy;              /* number of bytes read in the segy trace */
    int ntr;                /* number of actual input traces of the gather just read in*/
    int ngather, ntotal;    /* number of total input traces and gathers */
    int nt;                 /* number of points on trace		*/
    int i, ix, iy, itr, it; /* counters				*/
    int input, output, mix, lib;
    int ncorr;      /* length of corr window in samples	*/

    int verbose;
    int nc, nw[2];   /* mixing/weighting windows			*/
    int nx, ny, nxmax, nymax; /* max dimensions of input/output trace array */
    int *id2use, *id2apply;

    float dt;       /* time sample interval (sec)	*/
    float pnoise;   /* additive noise level		*/
    float mincorr, maxcorr, samplims;
    float delay, lwiener, lanti;
    segy tr, tro;
    FILE* fp = NULL;           /* file pointer for input wavelet    */
    cwp_String  filename;   /* filenames of input data */

    const float MIN_FILTER_LENGTH = 200.0;
    
    /* Initialize */
    initargs(argc, argv);
    requestdoc(1);

    /* Get parameters  */
    if (!getparint("verbose", &verbose))    verbose = 0;
    if (!getparint("lib", &lib))            lib = 0;
    if (!getparint("mix", &mix))            mix = 1;
    if (!getparint("output", &output))      output = 5;
    if (!getparint("input", &input))         input = 1;
    if (input < 1 || input > 2) err(" Invalid parameter input=%d for input trace pattern", input);
    if (!getparfloat("pnoise", &pnoise))    pnoise = PNOISE;

    /* read first trace */
    if ((nsegy = gettr(&tr)) < HDRBYTES ) err("Cannot get first trace");

    nt = tr.ns;
    dt = ((double) tr.dt) / 1000000.0;
    samplims = 1000.0*dt; // sampling interval in ms

    nx = tr.sfs;
    ny = tr.sfe;
    if(!getparint("nxmax", &nxmax)) nxmax = nx;
    if(!getparint("nymax", &nymax)) nymax = ny;
    if(input == 2) nxmax /= 2;

    /* get SU sorting key */
    if (!getparstring("key", &key)) key = "cdpt";
    type = hdtype(key);
    index = getindex(key);
    gethval(&tr, index, &val);

    /* get SU keys holding window parameters */
    if (!getparstring("mincorr", &key3)) key3 = "stas";
    type3 = hdtype(key3);
    index3 = getindex(key3);
    if (!getparstring("maxcorr", &key4)) key4 = "stae";
    type4 = hdtype(key4);
    index4 = getindex(key4);
    if (!getparstring("trid", &key5)) key5 = "trid";
    type5 = hdtype(key5);
    index5 = getindex(key5);

    // trace id
    int ncuse = countparval("use");
    if (ncuse > 0) {
        getparint("use", id2use);
    }
    int ncapply = countparval("apply");
    if (ncapply > 0) {
        getparint("apply", id2apply);
    }
    // mixing window for autocorrelation
    nc = countparval("nw");
    if (nc > 0) {
        getparint("nw", nw);
        if (nc == 1) nw[1] = 1;
        nw[0] = nw[0]/2 + 1;
        nw[1] = nw[1]/2 + 1;
    } else {
        nw[0] = nw[1] = 1;
    }

    if (!getparfloat("delay", &delay))  delay = 0.0;
    if (!getparfloat("fl", &lwiener))   lwiener = 1.0;
    if (!getparfloat("al", &lanti))       lanti = 0.4;
    int idelay = NINT(delay/dt);            // delay in samples of max. energy/spike
    int nwiener = NINT(lwiener/dt) + 1; // length in samples of wiener filter
    int ixcorr = (lanti > 0.0)? NINT(lanti/dt) : 0;  // starting index/offset for cross correlation in case of non-causal filter
    if (ixcorr > 0)  nwiener += ixcorr; // nwiener extended

    /* Allocate memory */
    int** trid = ealloc2int(nxmax, nymax);
    int** apply = ealloc2int(nxmax, nymax);
    int** use4acor = ealloc2int(nxmax, nymax);
    int** imincorr = ealloc2int(nxmax, nymax);
    int** imaxcorr = ealloc2int(nxmax, nymax);
    float* tmp = ealloc1float(nt);
    float* apwork = ealloc1float(nt);
    float* erfilt = ealloc1float(nt);
    float* wavelet = ealloc1float(nt);
    float* AvgAC = ealloc1float(nt);   // averaged/mixed acorr
    float* xcorr = ealloc1float(nt);
    float* dummy = ealloc1float(nt);
    float* wiener = ealloc1float(nt);
    float* spiker = ealloc1float(nt);
    float** weight = ealloc2float(nw[0], nw[1]);
    float*** wfilt = ealloc3float(nt, nxmax, nymax);
    float*** acorr = ealloc3float(nt, nxmax, nymax);
    // allocate memory input/output data traces
    float*** trdata = ealloc3float(nt, nxmax, nymax);
    float*** tr2app = (input == 2)? ealloc3float(nt, nxmax, nymax) : NULL;
    segyhdr** hdrs2d = (segyhdr**) ealloc2(nxmax, nymax, HDRBYTES);
    /* zero out data memory */
    memset(*trid, 0, nxmax*nymax*ISIZE);
    memset(*apply, 0, nxmax*nymax*ISIZE);
    memset(*use4acor, 0, nxmax*nymax*ISIZE);
    memset(*imincorr, 0, nxmax*nymax*ISIZE);
    memset(*imaxcorr, 0, nxmax*nymax*ISIZE);
    memset(wavelet, 0, nt*FSIZE);
    memset(xcorr, 0, nt*FSIZE);
    memset(*weight, 0, nw[0]*nw[1]*FSIZE);
    memset(**wfilt, 0, nymax*nxmax*nt*FSIZE);
    memset(**acorr, 0, nymax*nxmax*nt*FSIZE);
    memset(**trdata, 0, nymax*nxmax*nt*FSIZE);
    if (tr2app) memset(**tr2app, 0, nymax*nxmax*nt*FSIZE);
    memset(*hdrs2d, 0, nxmax*nymax*HDRBYTES);

    int ns = 0;  // input wavelet sample number
    if (getparstring("wavelet", &filename)) { // if wavelet file provided
        fp = efopen(filename, "r");
        if(fgettr(fp, &tro) < HDRBYTES) {
            err(" Failed to read input wavelet file %s", filename);
        };
        ns = tro.ns;
        if (ns > nt) err(" wavelet longer than data trace (%d > %d)", ns, nt);
        if (tro.dt != tr.dt) err(" wavelet must have the same sampling interval as data trace (tr.dt = %d != %d", tro.dt, tr.dt);
        memcpy(wavelet, tro.data, ns*FSIZE);
        efclose(fp);
    } else {
//        ns = idelay + 1;
 //       wavelet[idelay] = 1;
        ns = 1;
        wavelet[0] = 1;
    }

    // calculate weighting matrix
    CalcMix(mix, nw[0], nw[1], weight);
    
    /* Read headers and data while getting a count */
    int eof = 0;
    ngather = ntr = ntotal = 0;
    do { /* Main loop over traces/gather */
        if (nsegy > HDRBYTES) gethval(&tr, index, &valnew);
        else eof = 1; //END_OF_FILE
        if (nsegy > HDRBYTES && !valcmp(type, val, valnew)) { /* same key and more data*/
            iy = tr.nvs - 1;
            ix = tr.nhs/input - 1;
            if (ntr > nxmax*nymax - 1) err("  array dimension too small (%d < %d) traces input", nxmax*nymax, ntr+1);
            if (ix > nxmax - 1) err("  array dimension nxmax too small (%d < %d) traces input", nxmax, ix+1);
            if (iy > nymax - 1) err("  array dimension nymax too small (%d < %d) traces input", nymax, iy+1);
            if ((ntr + 1)%input == 0) memcpy(&hdrs2d[iy][ix], &tr, HDRBYTES);  // if upgoing trace also present, only copy its header
            memcpy((ntr%input)? tr2app[iy][ix] : trdata[iy][ix], tr.data, FSIZE*tr.ns);

            gethval(&tr, index3, &vala);
            mincorr = vtof(type3, vala);
            gethval(&tr, index4, &vala);
            maxcorr = vtof(type4, vala);
            gethval(&tr, index5, &vala);
            trid[iy][ix] = vtoi(type5, vala);
            imincorr[iy][ix] = NINT(0.001*mincorr/dt);
            imaxcorr[iy][ix] = NINT(0.001*maxcorr/dt);
            if (mincorr < 0 || maxcorr - mincorr < samplims || maxcorr >= (nt-1)*samplims)
                err("  Inconsistent autocorrelation window (0 < %1.0f < %1.0f <= %1.0f) for %d of %d-th gather (%s=%d)",
                        mincorr, maxcorr, (nt-1)*samplims, ntr+1, ngather+1, key, vtoi(type, val));
            if (maxcorr - mincorr < MIN_FILTER_LENGTH)
                warn("  Too short autocorrelation window (%1.0f - %1.0f < %1.0f) for %d of %d-th gather (%s=%d)",
                        maxcorr, mincorr, MIN_FILTER_LENGTH, ntr+1, ngather+1, key, vtoi(type, val));
            //if (trid[iy][ix] < 0)
            //    warn("  Negative trace id=%d for %d of %d-th gather (%s=%d)",
            //            trid[iy][ix], ntr, ngather, key, vtoi(type, val));

            ++ntr;
        } else { // new gather or END_OF_FILE
            ++ngather;
            ntotal += ntr;
            if (verbose > 1) warn("  Processing %d traces of %d-th gather (%s=%d)...", ntr, ngather, key, vtoi(type, val));

            // compute autocrrelation for all input traces
            itr = 0;
            for (iy=0; iy<nymax; ++iy) {
                for (ix=0; ix<nxmax; ++ix) {
                    ++itr;
                    if (trid[iy][ix] <= 0) continue; // skip zero trace
                    if (ncapply > 0) {
                        for (i=0; i<ncapply; ++i) if (trid[iy][ix] == id2apply[i])    apply[iy][ix] = 1;
                    } else {
                        apply[iy][ix] = 1;
                    }
                    if (ncuse > 0) {
                        for (i=0; i<ncuse; ++i)   if (trid[iy][ix] == id2use[i]) use4acor[iy][ix] = 1;
                    } else {
                        use4acor[iy][ix] = 1;
                    }

                    if (use4acor[iy][ix] == 0) continue;
                    // compute autocorrelation
                    ncorr = imaxcorr[iy][ix] - imincorr[iy][ix] + 1;
                    xcor(ncorr, 0, &trdata[iy][ix][imincorr[iy][ix]],
                         ncorr, 0, &trdata[iy][ix][imincorr[iy][ix]],
                         nwiener, 0, acorr[iy][ix]);
                    if (acorr[iy][ix][0] == 0.0) {
                        trid[iy][ix] = -trid[iy][ix];  // negate id for later identification
                        if (verbose > 3) warn("  Zero autocorrelation for trace %d of %d-th gather (%s=%d)",
                                itr, ngather, key, vtoi(type, val));
                    }
                }
            }

            itr = 0;
            for (iy=0; iy<nymax; ++iy) {
                for (ix=0; ix<nxmax; ++ix) {
                    if (trid[iy][ix] == 0) continue; // skip zero trace
                    memcpy(&tro, &hdrs2d[iy][ix], HDRBYTES);  // copy trace head
                    if (output == 1) { // output auto correlation
                        if (use4acor[iy][ix] == 0) continue;
                        tro.ns = nwiener;
                        memcpy(tro.data, acorr[iy][ix], nwiener*FSIZE);
                        puttr(&tro);
                        continue;
                    }

                    /* compute filter sizes and correlation number */
                    /* zero out filter vectors */
                    memset(wiener, 0, nwiener*FSIZE);
                    memset(spiker, 0, nwiener*FSIZE);
                    memset(AvgAC, 0, nwiener*FSIZE);
                    ncorr = imaxcorr[iy][ix] - imincorr[iy][ix] + 1;
                    // compute avaraging autocorrelation
                    memset(AvgAC, 0, nt*FSIZE);
                    if (nw[0] > 1 || nw[1] > 1) {
                        CalcAvgAC(nxmax, nymax, trid, acorr, nw[0], nw[1], weight, ix, iy, nwiener, AvgAC);
                    } else {
                        memcpy(AvgAC, acorr[iy][ix], nwiener*FSIZE);
                    }

                    if (output == 2) { // output weighted auto correlation
                        if (use4acor[iy][ix] == 0) continue;
                        tro.ns = nwiener;
                        memcpy(tro.data, AvgAC, nwiener*FSIZE);
                        puttr(&tro);
                        continue;
                    }

                    memset(xcorr, 0, nt*FSIZE);
                    if (lib == 1) {
                        int iopt = (ns == 1)? 3 : 4;
                        int ierr = 0;
                        float filtmax = 0.0;
//void VPWIEN_(float* WAVLT,  int* LWAVLT, float* DOUT, int* LDOUT, float* WSTAB,  float* WGAIN , int* LFIL, int* inpanti,
//        float* FILT, int* IOPT, int* IER, float* filmax, float* XC, float* AC, float* APWORK, float* ERFILT, float* TEMP, int* nmax);
                        vpwien_(&trdata[iy][ix][imincorr[iy][ix]], &ncorr, wavelet, &ns, &pnoise, &pnoise,
                            &nwiener, &ixcorr, wiener, &iopt, &ierr, &filtmax, xcorr, dummy,
                            apwork, erfilt, tmp, &nt);
                    // VPWIEN (WAVLT,  LWAVLT, DOUT,LDOUT,  WSTAB,  WGAIN , LFIL,  inpanti,
                    //      FILT ,  IOPT  , IER, filmax,  XC,AC,APWORK,ERFILT,TEMP,nmax)
                    }
                    else {
                        // compute cross correlation
                        //xcor(ns, idelay, wavelet, ncorr, 0, &trdata[iy][ix][imincorr[iy][ix]], nwiener, -ixcorr, xcorr);
                        xcor(ncorr, -ixcorr, &trdata[iy][ix][imincorr[iy][ix]], ns, idelay, wavelet, nwiener, 0, xcorr);
                    }

                    if (output == 3) { // output cross correlation
                        if (use4acor[iy][ix] == 0) continue;
                        tro.ns = nwiener;
                        memcpy(tro.data, xcorr, nwiener*FSIZE);
                        puttr(&tro);
                        continue;
                    }

                    AvgAC[0] *= 1.0 + 0.01*pnoise; /* pre-whitening */

                    /* Get inverse filter by Wiener-Levinson */
                    if (AvgAC[0]) stoepf(nwiener, AvgAC, xcorr, wiener, spiker);

                    if (output == 4) { // output wiener filter
                        if (use4acor[iy][ix] == 0) continue;
                        tro.ns = nwiener;
                        memcpy(tro.data, wiener, nwiener*FSIZE);
                        puttr(&tro);
                        continue;
                    }

                    if (apply[iy][ix] == 0) continue;
                    /* Convolve filter with trace  */
                    conv(nwiener, -ixcorr, wiener, nt, 0, (input == 2)? tr2app[iy][ix] : trdata[iy][ix], nt, 0, tro.data);
                    puttr(&tro);
                }
            }

            /* zero out data memory */
            memset(*trid, 0, nxmax*nymax*ISIZE);
            memset(*use4acor, 0, nxmax*nymax*ISIZE);
            memset(*apply, 0, nxmax*nymax*ISIZE);
            memset(*imincorr, 0, nxmax*nymax*ISIZE);
            memset(*imaxcorr, 0, nxmax*nymax*ISIZE);
            memset(**wfilt, 0, nymax*nxmax*ntr*FSIZE);
            memset(**acorr, 0, nymax*nxmax*nt*FSIZE);
            memset(**trdata, 0, nymax*nxmax*nt*FSIZE);
            if (tr2app) memset(**tr2app, 0, nymax*nxmax*nt*FSIZE);
            memset(*hdrs2d, 0, nxmax*nymax*HDRBYTES);

            val = valnew;
            ntr = 0;
            continue;
        }
        nsegy = gettr(&tr);
    } while (!eof);

    if (verbose) warn(" Totally %d traces of %d gathers are processed", ntotal, ngather);

    return (CWP_Exit());
}

int CalcMix(int mix, int nwx, int nwy, float** weight)
{
    int i, j;
    // only mix=1 implemented yet

    for (i=0; i<nwy; ++i) {
        for (j=0; j<nwx; ++j) {
            weight[i][j] = 1.0;
        }
    }
    return nwx*nwy;
}

int CalcAvgAC(int nxmax, int nymax, int** trid, float*** acorr,
        int nwx, int nwy, float** weight, int ix, int iy, int ncorr, float* AvgAC)
{
    int i, j, ixx, iyy, it, nw=0;

    for (it=0; it<ncorr; ++it) {
        float w = 0.0; // total weighting factor
        float z = 0.0; // weighted acorr at sample it
        for (i=0; i<nwy; ++i) {
            for (j=0; j<nwx; ++j) {
            iyy = iy - nwy/2 + i;
            ixx = ix - nwx/2 + j;
            if (ixx < 0 || ixx >= nxmax || iyy < 0 || iyy >= nymax) continue;
            ++nw;
            if (acorr[iyy][ixx][it] == 0.0) continue; // skip sample with zero acorr
                w += weight[i][j];
                z += weight[i][j]*acorr[iyy][ixx][it];
            }
        }
        AvgAC[it] = z / w;
    }
    return nw;
}

/**-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-c-
C
C
C               WIEN: A SUBROUTINE TO SOLVE WIENER'S EQUATIONS USING THE
C               LEVINSON RECURSIVE ALGORITHM. TAKEN FROM 'DIGITAL
C               FILTERING' BY A.MESKO.
C
C               IT PRODUCES A FILTER (C) WHICH WHEN CONVOLVED WITH
C               THE INPUT SIGNAL X WILL PRODUCE THE DESIRED
C               OUTPUT Z.
C
C               PARAMETERS:
C
C               R(NXC) REAL VECTOR CONTAINING THE AUTOCORRELATION OF
C               THE SIGNAL X .IT SHOULD BE PADDED WITH ZEROS BEYOND
C               THE LENGTH OF X.
C               THE VALUES SHOULD FIRST BE DIVIDED BY THE AUTO-
C               CORRELATION OF THE Z SIGNAL EVALUATED AT TIME ZERO.
C
C               G(NXC) : THE CROSS CORRELATION OF THE INPUT SIGNAL X
C               ,WITH THE OUTPUT Z,DIVIDED BY THE AUTOCORRELATION OF
C               Z EVALUATED AT ZERO TIME.
C
C               NXC: INTEGER, THE LENGTH OF THE CROSS CORRELATION
C               VECTOR.
C
C               C(NXC) :REAL,THE OUTPUT FILTER COEFFICIENTS.
C
 ************************************************************************/
int WIEN(int NXC, float* R, float* G, float* C)
{
    int I, M, MP1;
    float TEMP[NXC], A[NXC];
    //float K, L;


    float RMAX = 0.72E33;

    // Set recursion start values.C
    A[0] = 1.0;
    C[0] = G[0] / R[0];
    float ALPHA = R[0];
    float BETA = R[1];
    float GAMMA = C[0] * R[1];
    if (C[0] > RMAX) return -1;


    //   Main loop
    for (MP1 = 1; MP1 < NXC - 1; ++MP1) {
        float K = -BETA / ALPHA;
        if (K > RMAX) return -1;
        M = MP1 - 1;

        // Part 2 (from mesko)
        for (I = 1; I < M; ++I) TEMP[I] = A[I] + K * A[M - I + 2];
        for (I = 1; I < M; ++I) A[I] = TEMP[I];
        A[MP1] = K * A[0];

        //  Part 3C
        ALPHA = ALPHA + K * BETA;
        BETA = 0.0;
        for (I = 1; I < MP1; ++I) BETA = BETA + A[I] * R[M + 3 - I];

        //  Part 4
        float L = (G[MP1] - GAMMA) / ALPHA;

        //  Part 5
        for (I = 1; I < M; ++I) C[I] = C[I] + L * A[M - I + 2];
        C[MP1] = L * A[1];

        // Part 6
        GAMMA = 0.0;
        for (I = 1; I < MP1; ++I) GAMMA = GAMMA + C[I] * R[M - I + 3];
    }

    return 0;
}

